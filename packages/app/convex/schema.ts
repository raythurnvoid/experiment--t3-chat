import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";
import type { MessageStorageEntry } from "@assistant-ui/react";
import type { UIMessage } from "ai";

const app_convex_schema = defineSchema({
	threads: defineTable({
		title: v.string(),
		archived: v.boolean(),
		/** timestamp in milliseconds */
		last_message_at: v.number(),
		workspace_id: v.string(),
		created_by: v.string(),
		updated_by: v.string(),
		/** timestamp in milliseconds */
		updated_at: v.number(),
		external_id: v.union(v.string(), v.null()),
		project_id: v.string(),
		starred: v.optional(v.boolean()),
		// Note: Convex automatically provides _id and _creationTime fields
		// so we don't need separate id and createdAt fields
	})
		.index("by_workspace", ["workspace_id"])
		.index("by_last_message", ["last_message_at"])
		.index("by_archived", ["archived"])
		.index("by_workspace_and_archived", ["workspace_id", "archived"]),

	/**
	 * Each doc should be compatible with {@link MessageStorageEntry} from `@assistant-ui/react`
	 */
	messages: defineTable({
		parent_id: v.union(v.id("messages"), v.null()),
		thread_id: v.id("threads"),
		created_by: v.string(),
		updated_by: v.string(),
		/** timestamp in milliseconds */
		updated_at: v.number(),
		format: v.string(),
		height: v.number(),

		/**
		 * Same as but `content.id` but top-level to make it indexable with Convex.
		 */
		client_generated_message_id: v.optional(v.string()),

		/**
		 * AI SDK 5 {@link UIMessage} object without `id` property as the id is generated by convex.
		 **/
		content: v.object({
			role: v.union(v.literal("system"), v.literal("user"), v.literal("assistant")),
			metadata: v.optional(v.record(v.string(), v.any())),
			parts: v.array(
				v.union(
					// Text part
					v.object({
						type: v.literal("text"),
						text: v.string(),
						state: v.optional(v.union(v.literal("streaming"), v.literal("done"))),
						providerMetadata: v.optional(v.record(v.string(), v.any())),
					}),
					// Reasoning part
					v.object({
						type: v.literal("reasoning"),
						text: v.string(),
						state: v.optional(v.union(v.literal("streaming"), v.literal("done"))),
						providerMetadata: v.optional(v.record(v.string(), v.any())),
					}),
					// Source URL part
					v.object({
						type: v.literal("source-url"),
						sourceId: v.string(),
						url: v.string(),
						title: v.optional(v.string()),
						providerMetadata: v.optional(v.record(v.string(), v.any())),
					}),
					// Source document part
					v.object({
						type: v.literal("source-document"),
						sourceId: v.string(),
						mediaType: v.string(),
						title: v.string(),
						filename: v.optional(v.string()),
						providerMetadata: v.optional(v.record(v.string(), v.any())),
					}),
					// File part (filtered out by adapter but kept for completeness)
					v.object({
						type: v.literal("file"),
						mediaType: v.string(),
						filename: v.optional(v.string()),
						url: v.string(),
						providerMetadata: v.optional(v.record(v.string(), v.any())),
					}),
					// Step start part
					v.object({
						type: v.literal("step-start"),
					}),
					// Dynamic tool part
					v.union(
						// state: input-streaming
						v.object({
							type: v.literal("dynamic-tool"),
							toolName: v.string(),
							toolCallId: v.string(),
							state: v.literal("input-streaming"),
							input: v.any(),
						}),
						// state: input-available
						v.object({
							type: v.literal("dynamic-tool"),
							toolName: v.string(),
							toolCallId: v.string(),
							state: v.literal("input-available"),
							input: v.any(),
							callProviderMetadata: v.optional(v.record(v.string(), v.any())),
						}),
						// state: output-available
						v.object({
							type: v.literal("dynamic-tool"),
							toolName: v.string(),
							toolCallId: v.string(),
							state: v.literal("output-available"),
							input: v.any(),
							output: v.any(),
							callProviderMetadata: v.optional(v.record(v.string(), v.any())),
						}),
						// state: output-error
						v.object({
							type: v.literal("dynamic-tool"),
							toolName: v.string(),
							toolCallId: v.string(),
							state: v.literal("output-error"),
							input: v.any(),
							errorText: v.string(),
							callProviderMetadata: v.optional(v.record(v.string(), v.any())),
						}),
					),
					// Generic tool part (for tool-${toolName} types)
					v.union(
						// state: input-streaming
						v.object({
							type: v.string(), // "tool-${toolName}"
							toolCallId: v.string(),
							state: v.literal("input-streaming"),
							input: v.any(),
							providerExecuted: v.optional(v.boolean()),
						}),
						// state: input-available
						v.object({
							type: v.string(), // "tool-${toolName}"
							toolCallId: v.string(),
							state: v.literal("input-available"),
							input: v.any(),
							providerExecuted: v.optional(v.boolean()),
							callProviderMetadata: v.optional(v.record(v.string(), v.any())),
						}),
						// state: output-available
						v.object({
							type: v.string(), // "tool-${toolName}"
							toolCallId: v.string(),
							state: v.literal("output-available"),
							input: v.any(),
							output: v.any(),
							providerExecuted: v.optional(v.boolean()),
							callProviderMetadata: v.optional(v.record(v.string(), v.any())),
						}),
						// state: output-error
						v.object({
							type: v.string(), // "tool-${toolName}"
							toolCallId: v.string(),
							state: v.literal("output-error"),
							input: v.any(),
							errorText: v.string(),
							providerExecuted: v.optional(v.boolean()),
							callProviderMetadata: v.optional(v.record(v.string(), v.any())),
							rawInput: v.optional(v.any()),
						}),
					),
					// Generic data part (for data-${dataType} types)
					v.object({
						type: v.string(), // Covers "data-${dataType}" pattern
						id: v.optional(v.string()),
						data: v.any(),
					}),
				),
			),
		}),
	})
		.index("by_client_generated_message_id", ["client_generated_message_id"])
		.index("by_thread", ["thread_id"])
		.index("by_parent", ["parent_id"])
		.index("by_thread_and_parent", ["thread_id", "parent_id"])
		.index("by_updated_at", ["updated_at"]),

	pages: defineTable({
		/** Workspace ID extracted from roomId */
		workspace_id: v.string(),
		/** Project ID extracted from roomId */
		project_id: v.string(),
		/** Document ID generated client side */
		page_id: v.string(),
		/** Display name used in path resolution */
		name: v.string(),
		/** Plain text content extracted from the editor for search and display */
		text_content: v.string(),
		/** Document version - always 0 for now until versioning is implemented */
		version: v.number(),
		/** Whether document is archived */
		is_archived: v.boolean(),
		/** "root" for root items */
		parent_id: v.string(),
		/** Created by user ID */
		created_by: v.string(),
		/** Updated by user ID */
		updated_by: v.string(),
		/** timestamp in milliseconds when document was last updated */
		updated_at: v.number(),
	})
		.index("by_workspace_project", ["workspace_id", "project_id"])
		.index("by_workspace_project_and_page_id", ["workspace_id", "project_id", "page_id"])
		.index("by_workspace_project_and_parent_id", ["workspace_id", "project_id", "parent_id"])
		.index("by_workspace_project_and_parent_id_and_name", ["workspace_id", "project_id", "parent_id", "name"])
		.index("by_parent_id_and_is_archived", ["parent_id", "is_archived"])
		.index("by_workspace_project_and_parent_id_and_name_and_is_archived", [
			"workspace_id",
			"project_id",
			"parent_id",
			"name",
			"is_archived",
		])
		.index("by_parent_id_and_name", ["parent_id", "name"])
		.index("by_parent_id", ["parent_id"])
		.searchIndex("search_text_content", {
			searchField: "text_content",
			filterFields: ["workspace_id", "project_id"],
		}),

	/**
	 * Pending edits overlay used to stage AI-written content until user saves.
	 * Keys by user/thread/page to allow parallel staging across chat threads.
	 */
	ai_chat_pending_edits: defineTable({
		workspace_id: v.string(),
		project_id: v.string(),
		user_id: v.string(),
		thread_id: v.string(),
		page_id: v.string(),
		base_content: v.string(),
		modified_content: v.string(),
		updated_at: v.number(),
	})
		.index("by_user_thread_page", ["user_id", "thread_id", "page_id"])
		.index("by_page", ["page_id"]),

	/**
	 * Tracks scheduled cleanup tasks to remove a user's pending edits.
	 * One task per user; canceled on heartbeat, executed if user remains offline.
	 */
	ai_chat_pending_edits_cleanup_tasks: defineTable({
		user_id: v.string(),
		scheduled_function_id: v.id("_scheduled_functions"),
	}).index("by_user_id", ["user_id"]),

	page_updates_richtext_broadcast: defineTable({
		/** Workspace ID extracted from roomId */
		workspace_id: v.string(),
		/** Project ID extracted from roomId */
		project_id: v.string(),
		/** Related page id (same as pages.page_id) */
		page_id: v.string(),
		/** Text content to broadcast */
		text_content: v.string(),
	})
		.index("by_workspace_project_and_page_id", ["workspace_id", "project_id", "page_id"])
		.index("by_page_id", ["page_id"]),

	page_updates_markdown_broadcast: defineTable({
		/** Workspace ID extracted from roomId */
		workspace_id: v.string(),
		/** Project ID extracted from roomId */
		project_id: v.string(),
		/** Related page id (same as pages.page_id) */
		page_id: v.string(),
		/** Text content to broadcast */
		text_content: v.string(),
	})
		.index("by_workspace_project_and_page_id", ["workspace_id", "project_id", "page_id"])
		.index("by_page_id", ["page_id"]),
});

export default app_convex_schema;

export { app_convex_schema };

// @ts-expect-error unused type
type _ = //
	MessageStorageEntry<any> | UIMessage;
