import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";
import type { MessageStorageEntry } from "@assistant-ui/react";
import type { UIMessage } from "ai";

const app_convex_schema = defineSchema({
	// #region AI
	threads: defineTable({
		title: v.string(),
		archived: v.boolean(),
		/** timestamp in milliseconds */
		last_message_at: v.number(),
		workspace_id: v.string(),
		created_by: v.string(),
		updated_by: v.string(),
		/** timestamp in milliseconds */
		updated_at: v.number(),
		external_id: v.union(v.string(), v.null()),
		project_id: v.string(),
		starred: v.optional(v.boolean()),
		// Note: Convex automatically provides _id and _creationTime fields
		// so we don't need separate id and createdAt fields
	})
		.index("by_workspace", ["workspace_id"])
		.index("by_last_message", ["last_message_at"])
		.index("by_archived", ["archived"])
		.index("by_workspace_and_archived", ["workspace_id", "archived"]),

	/**
	 * Each doc should be compatible with {@link MessageStorageEntry} from `@assistant-ui/react`
	 */
	messages: defineTable({
		parent_id: v.union(v.id("messages"), v.null()),
		thread_id: v.id("threads"),
		created_by: v.string(),
		updated_by: v.string(),
		/** timestamp in milliseconds */
		updated_at: v.number(),
		format: v.string(),
		height: v.number(),

		/**
		 * Same as but `content.id` but top-level to make it indexable with Convex.
		 */
		client_generated_message_id: v.optional(v.string()),

		/**
		 * AI SDK 5 {@link UIMessage} object without `id` property as the id is generated by convex.
		 **/
		content: v.object({
			role: v.union(v.literal("system"), v.literal("user"), v.literal("assistant")),
			metadata: v.optional(v.record(v.string(), v.any())),
			parts: v.array(
				v.union(
					// Text part
					v.object({
						type: v.literal("text"),
						text: v.string(),
						state: v.optional(v.union(v.literal("streaming"), v.literal("done"))),
						providerMetadata: v.optional(v.record(v.string(), v.any())),
					}),
					// Reasoning part
					v.object({
						type: v.literal("reasoning"),
						text: v.string(),
						state: v.optional(v.union(v.literal("streaming"), v.literal("done"))),
						providerMetadata: v.optional(v.record(v.string(), v.any())),
					}),
					// Source URL part
					v.object({
						type: v.literal("source-url"),
						sourceId: v.string(),
						url: v.string(),
						title: v.optional(v.string()),
						providerMetadata: v.optional(v.record(v.string(), v.any())),
					}),
					// Source document part
					v.object({
						type: v.literal("source-document"),
						sourceId: v.string(),
						mediaType: v.string(),
						title: v.string(),
						filename: v.optional(v.string()),
						providerMetadata: v.optional(v.record(v.string(), v.any())),
					}),
					// File part (filtered out by adapter but kept for completeness)
					v.object({
						type: v.literal("file"),
						mediaType: v.string(),
						filename: v.optional(v.string()),
						url: v.string(),
						providerMetadata: v.optional(v.record(v.string(), v.any())),
					}),
					// Step start part
					v.object({
						type: v.literal("step-start"),
					}),
					// Dynamic tool part
					v.union(
						// state: input-streaming
						v.object({
							type: v.literal("dynamic-tool"),
							toolName: v.string(),
							toolCallId: v.string(),
							state: v.literal("input-streaming"),
							input: v.any(),
						}),
						// state: input-available
						v.object({
							type: v.literal("dynamic-tool"),
							toolName: v.string(),
							toolCallId: v.string(),
							state: v.literal("input-available"),
							input: v.any(),
							callProviderMetadata: v.optional(v.record(v.string(), v.any())),
						}),
						// state: output-available
						v.object({
							type: v.literal("dynamic-tool"),
							toolName: v.string(),
							toolCallId: v.string(),
							state: v.literal("output-available"),
							input: v.any(),
							output: v.any(),
							callProviderMetadata: v.optional(v.record(v.string(), v.any())),
						}),
						// state: output-error
						v.object({
							type: v.literal("dynamic-tool"),
							toolName: v.string(),
							toolCallId: v.string(),
							state: v.literal("output-error"),
							input: v.any(),
							errorText: v.string(),
							callProviderMetadata: v.optional(v.record(v.string(), v.any())),
						}),
					),
					// Generic tool part (for tool-${toolName} types)
					v.union(
						// state: input-streaming
						v.object({
							type: v.string(), // "tool-${toolName}"
							toolCallId: v.string(),
							state: v.literal("input-streaming"),
							input: v.any(),
							providerExecuted: v.optional(v.boolean()),
						}),
						// state: input-available
						v.object({
							type: v.string(), // "tool-${toolName}"
							toolCallId: v.string(),
							state: v.literal("input-available"),
							input: v.any(),
							providerExecuted: v.optional(v.boolean()),
							callProviderMetadata: v.optional(v.record(v.string(), v.any())),
						}),
						// state: output-available
						v.object({
							type: v.string(), // "tool-${toolName}"
							toolCallId: v.string(),
							state: v.literal("output-available"),
							input: v.any(),
							output: v.any(),
							providerExecuted: v.optional(v.boolean()),
							callProviderMetadata: v.optional(v.record(v.string(), v.any())),
						}),
						// state: output-error
						v.object({
							type: v.string(), // "tool-${toolName}"
							toolCallId: v.string(),
							state: v.literal("output-error"),
							input: v.any(),
							errorText: v.string(),
							providerExecuted: v.optional(v.boolean()),
							callProviderMetadata: v.optional(v.record(v.string(), v.any())),
							rawInput: v.optional(v.any()),
						}),
					),
					// Generic data part (for data-${dataType} types)
					v.object({
						type: v.string(), // Covers "data-${dataType}" pattern
						id: v.optional(v.string()),
						data: v.any(),
					}),
				),
			),
		}),
	})
		.index("by_client_generated_message_id", ["client_generated_message_id"])
		.index("by_thread", ["thread_id"])
		.index("by_parent", ["parent_id"])
		.index("by_thread_and_parent", ["thread_id", "parent_id"])
		.index("by_updated_at", ["updated_at"]),

	/**
	 * Pending edits overlay used to stage AI-written content until user saves.
	 * Keys by user/thread/page to allow parallel staging across chat threads.
	 */
	ai_chat_pending_edits: defineTable({
		workspace_id: v.string(),
		project_id: v.string(),
		user_id: v.string(),
		thread_id: v.string(),
		page_id: v.string(),
		base_content: v.string(),
		modified_content: v.string(),
		updated_at: v.number(),
	})
		.index("by_user_thread_page", ["user_id", "thread_id", "page_id"])
		.index("by_page", ["page_id"]),

	/**
	 * Tracks scheduled cleanup tasks to remove a user's pending edits.
	 * One task per user; canceled on heartbeat, executed if user remains offline.
	 */
	ai_chat_pending_edits_cleanup_tasks: defineTable({
		user_id: v.string(),
		scheduled_function_id: v.id("_scheduled_functions"),
	}).index("by_user_id", ["user_id"]),
	// #endregion AI

	// #region Pages
	pages: defineTable({
		/** Workspace ID extracted from roomId */
		workspace_id: v.string(),
		/** Project ID extracted from roomId */
		project_id: v.string(),
		/** Document ID generated client side */
		page_id: v.string(),
		/** Display name used in path resolution */
		name: v.string(),
		/** ID of the markdown content for the page */
		markdown_content_id: v.optional(v.id("pages_markdown_content")),
		/** ID of the last YJS sequence for the page */
		yjs_last_sequence_id: v.optional(v.id("pages_yjs_docs_last_sequences")),
		/** ID of the last YJS sequence for the page */
		yjs_snapshot_id: v.optional(v.id("pages_yjs_snapshots")),
		/** Document version - always 0 for now until versioning is implemented */
		version: v.number(),
		/** Whether document is archived */
		is_archived: v.boolean(),
		/** "root" for root items */
		parent_id: v.string(),
		/** Created by user ID */
		created_by: v.string(),
		/** Updated by user ID */
		updated_by: v.string(),
		/** timestamp in milliseconds when document was last updated */
		updated_at: v.number(),
	})
		.index("by_workspace_project_and_page_id", ["workspace_id", "project_id", "page_id"])
		.index("by_workspace_project_parent_id_and_name", ["workspace_id", "project_id", "parent_id", "name"])
		.index("by_workspace_project_parent_id_and_is_archived", ["workspace_id", "project_id", "parent_id", "is_archived"])
		.index("by_workspace_project_and_name", ["workspace_id", "project_id", "name"]),
	/**
	 * Table to store markdown content for pages.
	 */
	pages_markdown_content: defineTable({
		workspace_id: v.string(),
		project_id: v.string(),
		page_id: v.id("pages"),
		/** Markdown content */
		content: v.string(),
		/** Whether document is archived */
		is_archived: v.boolean(),
		/** YJS sequence to know the sync status */
		yjs_sequence: v.number(),
		updated_at: v.number(),
		updated_by: v.string(),
	}).searchIndex("search_by_content", {
		searchField: "content",
		filterFields: ["workspace_id", "project_id", "is_archived"],
	}),

	pages_yjs_snapshots: defineTable({
		workspace_id: v.string(),
		project_id: v.string(),
		page_id: v.id("pages"),
		sequence: v.number(),
		snapshot_update: v.bytes(),
		created_by: v.string(),
		updated_by: v.string(),
		updated_at: v.number(),
	}).index("by_workspace_project_and_page_id_and_sequence", ["workspace_id", "project_id", "page_id", "sequence"]),

	pages_yjs_updates: defineTable({
		workspace_id: v.string(),
		project_id: v.string(),
		page_id: v.id("pages"),
		sequence: v.number(),
		update: v.bytes(),
		origin: v.union(
			v.object({
				type: v.literal("USER_EDIT"),
				/**
				 * Even though sessions are destroyed when users disconnect, this
				 * is usedful to differentiate between local and remote edits.
				 */
				session_id: v.string(),
			}),
			v.object({
				type: v.literal("USER_SNAPSHOT_RESTORE"),
				snapshot_id: v.id("pages_snapshots"),
			}),
			v.object({
				type: v.literal("USER_AI_EDIT"),
			}),
		),
		created_by: v.string(),
		created_at: v.number(),
	}).index("by_workspace_project_and_page_id_and_sequence", ["workspace_id", "project_id", "page_id", "sequence"]),

	pages_yjs_docs_last_sequences: defineTable({
		workspace_id: v.string(),
		project_id: v.string(),
		page_id: v.id("pages"),
		last_sequence: v.number(),
	}).index("by_workspace_project_and_page_id", ["workspace_id", "project_id", "page_id"]),

	/**
	 * Internal table to track scheduled YJS snapshot updates.
	 */
	pages_yjs_snapshot_schedules: defineTable({
		page_id: v.id("pages"),
		scheduled_function_id: v.id("_scheduled_functions"),
	}).index("by_page_id", ["page_id"]),

	pages_snapshots: defineTable({
		workspace_id: v.string(),
		project_id: v.string(),
		page_id: v.id("pages"),
		created_by: v.id("users"),
		is_archived: v.optional(v.boolean()),
	})
		.index("by_page_id", ["page_id"])
		.index("by_page_id_and_is_archived", ["page_id", "is_archived"])
		.index("by_workspace_project", ["workspace_id", "project_id"]),

	pages_snapshots_contents: defineTable({
		workspace_id: v.string(),
		project_id: v.string(),
		page_snapshot_id: v.id("pages_snapshots"),
		content: v.string(),
		page_id: v.id("pages"),
	}).index("by_workspace_project_and_page_snapshot_id", ["workspace_id", "project_id", "page_snapshot_id"]),
	// #endregion Pages

	// #region Human Threads
	/**
	 * Human thread messages table - a single table that represents both threads and messages.
	 * Root messages (thread_id = null) act as thread heads.
	 * Child messages (thread_id = rootId) form a linked list via parent_id.
	 */
	human_thread_messages: defineTable({
		/** Workspace ID for multi-tenant scoping */
		workspace_id: v.string(),
		/** Project ID for multi-tenant scoping */
		project_id: v.string(),
		/**
		 * null → this row is a root message (thread head).
		 * non-null → this row is a child message belonging to the root whose id is thread_id.
		 */
		thread_id: v.union(v.id("human_thread_messages"), v.null()),
		/**
		 * null for roots.
		 * For children: points to the previous message in that thread's linear chain.
		 */
		parent_id: v.union(v.id("human_thread_messages"), v.null()),
		/**
		 * Only meaningful on roots: id of the last child in the chain, or null if there are no children.
		 */
		last_child_id: v.union(v.id("human_thread_messages"), v.null()),
		/** Soft delete / hide flag, especially for root messages */
		is_archived: v.boolean(),
		/** User ID who created this message */
		created_by: v.string(),
		/** Markdown content; produced from TipTap rich text on submit */
		content: v.string(),
	}),
	// #endregion Human Threads

	// #region Presence
	presence_data: defineTable({
		roomId: v.string(),
		userId: v.string(),
		data: v.any(),
	})
		.index("by_room_user", ["roomId", "userId"])
		.index("by_room", ["roomId"]),
	// #endregion Presence

	// #region Users
	users: defineTable({
		/** Clerk user ID, null for anonymous users */
		clerkUserId: v.union(v.string(), v.null()),
		/** Anonymous auth JWT; null once upgraded */
		anonymousAuthToken: v.union(v.string(), v.null()),
		/** Display name, e.g. "anonymous_<uuid>" for anonymous users */
		displayName: v.string(),
	}).index("by_clerk_user_id", ["clerkUserId"]),
	// #endregion Users
});

export default app_convex_schema;

export { app_convex_schema };

// @ts-expect-error unused type
type _ = //
	MessageStorageEntry<any> | UIMessage;
