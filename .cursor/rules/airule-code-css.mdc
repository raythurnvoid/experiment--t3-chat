CSS Guidelines for React Components

# CSS Approach for This Project

This project uses both **Tailwind CSS** and **vanilla CSS files**.

## Default Approach: Tailwind CSS

**By default, you should use Tailwind utility classes** for styling components unless the user explicitly requests vanilla CSS.

Examples of when to use Tailwind:

- Component styling with utilities: `className="flex items-center gap-2 px-4 py-2"`
- Transitions and animations: `transition-all duration-150 delay-200`
- Responsive design: `md:flex-row lg:gap-4`
- State-based styling: `hover:bg-blue-600 focus:ring-2`

## When to Create Vanilla CSS Files

**Only create separate `.css` files** when:

1. **User explicitly requests vanilla CSS** ("use vanilla CSS", "create a CSS file", etc.)
2. **Complex styling patterns** that require:
   - Low-specificity `:where()` selectors
   - Advanced CSS nesting
   - Complex state management that's difficult with Tailwind
   - Component-specific CSS custom properties

## Guidelines Application

The guidelines below apply **only when creating vanilla CSS files**, not when using Tailwind utility classes.

# File Structure

- Each component's CSS must be in a separate `.css` file
- File must be imported in the corresponding `.tsx` file
- Use modern CSS features including CSS nesting

# Layering

```css
@layer common-components {
	/* All component styles must be wrapped in this layer */
}
```

# Selectors and Specificity

- Use `:where()` for component's own classes to keep specificity low
- This allows easy overriding and prevents specificity wars

```css
/* ✅ Good */
:where(.Button) {
	/* base styles */
}

/* ❌ Bad */
.Button {
	/* base styles */
}
```

# Class Naming Convention

## Base Component

- Use PascalCase for component class names
- Match class name with component name
- Example: `.Button`, `.Card`, `.Modal`

## Modifiers

- Use single dash with explicit modifier type naming
- Pattern: `ComponentName-modifierType-value`
- **Variants**: `Button-variant-default`, `Button-variant-destructive`
- **Sizes**: `Button-size-default`, `Button-size-sm`, `Button-size-lg`
- **States**: `Button-state-loading`, `Button-state-disabled`

```css
/* ✅ Good - explicit modifier naming */
:where(.Button-variant-destructive) {
}
:where(.Button-size-lg) {
}

/* ❌ Bad - double dashes or unclear naming */
:where(.Button--destructive) {
}
:where(.Button--lg) {
}
```

## CSS Selector Compatibility: Critical Dash Requirements

### Important Rule for CSS Selectors

**CRITICAL**: When creating class names that will be used in CSS selectors (including Tailwind's `has-[]`, `:not()`, `:is()`, `:where()`, etc.), you **MUST use dashes (kebab-case) instead of underscores** for the selectors to work properly.

### Why Dashes Are Required

- **CSS Standard**: CSS class selectors expect dashes as word separators
- **Tailwind Compatibility**: Tailwind's `has-[]` selector only works with valid CSS class names
- **Browser Parsing**: Browsers parse CSS class names with dashes correctly
- **Selector Matching**: CSS selector engines rely on standard class naming conventions

### Examples of Correct CSS-Compatible Class Names

```css
/* ✅ Correct: Dashes work in all CSS selectors */
:where(.Button-variant-primary) {
	background: hsl(var(--primary));
}

:where(.Card-size-large) {
	padding: 2rem;
}

/* In Tailwind has-[] selectors */
.has-\[\.Button-variant-primary\:focus-visible\]\:ring-2 {
	/* This works correctly */
}

/* ❌ Incorrect: Underscores don't work in CSS selectors */
:where(.Button_variant_primary) {
	/* This may not work as expected */
}

.has-\[\.Button_variant_primary\:focus-visible\]\:ring-2 {
	/* This will NOT work */
}
```

### Class Naming Pattern for CSS Files

When creating CSS files, ensure all class names use dashes:

```css
/* ✅ Correct CSS class naming */
:where(.MessageComposer-input-field) {
	/* Base styles */
}

:where(.MessageComposer-send-button) {
	/* Button styles */
}

:where(.MessageComposer-attachment-area) {
	/* Attachment styles */
}
```

### Integration with React Components

When your CSS classes need to work with Tailwind selectors or other CSS features, ensure the class values in your React components use dashes:

```tsx
// In React component file
const MessageComposer_class_names = {
	root: "MessageComposer",
	input_field: "MessageComposer-input-field", // ✅ Dashes for CSS compatibility
	send_button: "MessageComposer-send-button", // ✅ Dashes for CSS compatibility
};

// In CSS file
:where(.MessageComposer-input-field) {
	border: 1px solid hsl(var(--border));
}

// In Tailwind has-[] selectors
<div className="has-[.MessageComposer-input-field:focus-visible]:ring-2">
```

### When to Use Dashes vs Underscores

- **CSS class values**: Always use dashes (`MessageComposer-input-field`)
- **React object properties**: Use underscores (`input_field`)
- **Variable names**: Use underscores (`class_names`)
- **CSS selectors**: Always use dashes (`.MessageComposer-input-field`)

# Modern CSS Nesting

- Use the `&` syntax for nesting selectors within a component
- Keep all component states within the main `:where()` selector
- For nested selectors that need low specificity, use `&:where(:hover)` syntax

```css
/* ✅ Good - using modern CSS nesting with proper :where() usage */
:where(.Button) {
	/* Base styles */

	&:where(:hover) {
		/* Hover styles with low specificity */
	}

	&:where(:focus-visible) {
		/* Focus styles with low specificity */
	}

	&:where(svg) {
		/* SVG child styles with low specificity */
		pointer-events: none;
		flex-shrink: 0;
	}
}

/* ❌ Bad - separate selectors increase complexity */
:where(.Button) {
	/* Base styles */
}

:where(.Button:hover) {
	/* Hover styles - separate selector */
}
```

# Property Grouping and Organization

- Use empty lines to group related properties
- Common property groups:
  - Box model (position, display, box-sizing)
  - Layout (flex, grid, gap, align-items)
  - Spacing (padding, margin)
  - Typography (font properties)
  - Visual (color, background, border)
  - Transitions and animations

```css
:where(.Button) {
	box-sizing: border-box;
	position: relative;

	display: inline-flex;
	align-items: center;
	justify-content: center;
	gap: 0.5rem;

	padding: 0.5rem 1rem;
	border-radius: 0.375rem;

	font-size: 0.875rem;
	font-weight: 500;
	line-height: 1.25rem;

	background: hsl(var(--primary));
	color: hsl(var(--primary-foreground));

	transition: all 150ms cubic-bezier(0.4, 0, 0.2, 1);
}
```

# CSS Custom Properties

- Use CSS custom properties with `hsl()` function
- Pattern: `hsl(var(--variable-name))`
- For opacity variants: `hsl(var(--variable-name) / 0.9)`

```css
/* ✅ Good */
background: hsl(var(--primary));
color: hsl(var(--primary-foreground));
border-color: hsl(var(--destructive) / 0.2);

/* ❌ Bad - missing hsl() wrapper */
background: var(--primary);
```

# Dark Mode Support

- Use `@media (prefers-color-scheme: dark)` for dark theme handling
- Place dark mode overrides within the component scope

```css
:where(.Button-variant-outline) {
	background: hsl(var(--background));
	border: 1px solid hsl(var(--border));

	@media (prefers-color-scheme: dark) {
		background: hsl(var(--input) / 0.3);
		border-color: hsl(var(--input));
	}
}
```

# State Handling

- Use `&:where()` syntax for interactive states
- Handle disabled, focus, hover, and active states consistently

```css
:where(.Button) {
	/* Base styles */

	&:where(:disabled) {
		pointer-events: none;
		opacity: 0.5;
	}

	&:where(:focus-visible) {
		outline: none;
		border-color: hsl(var(--ring));
		box-shadow: 0 0 0 3px hsl(var(--ring) / 0.5);
	}

	&:where(:hover) {
		background: hsl(var(--primary) / 0.9);
	}
}
```

# Child Element Styling

- Wrap child selectors in `:where()` for low specificity
- Use semantic child selectors

```css
:where(.Button) {
	/* Base styles */

	&:where(svg) {
		pointer-events: none;
		flex-shrink: 0;

		&:not([class*="size-"]) {
			width: 1rem;
			height: 1rem;
		}
	}

	&:where(:has(> svg)) {
		padding-left: 0.75rem;
		padding-right: 0.75rem;
	}
}
```

# Converting from Tailwind

When converting from Tailwind utility classes to CSS:

1. **Group related utilities**: Convert spacing, colors, and layout utilities into logical CSS property groups
2. **Preserve responsive behavior**: Use CSS custom properties and media queries
3. **Maintain design tokens**: Use CSS custom properties that match the design system
4. **Handle arbitrary selectors**: Convert Tailwind's arbitrary selectors like `[&_svg]:size-4` to proper nested CSS

```css
/* Before: Tailwind utilities */
/* className="inline-flex items-center gap-2 px-4 py-2 bg-primary text-primary-foreground hover:bg-primary/90" */

/* After: CSS properties with dash-based class names */
:where(.Button) {
	display: inline-flex;
	align-items: center;
	gap: 0.5rem;

	padding: 0.5rem 1rem;

	background: hsl(var(--primary));
	color: hsl(var(--primary-foreground));

	&:where(:hover) {
		background: hsl(var(--primary) / 0.9);
	}
}

/* Variant classes use dashes for CSS compatibility */
:where(.Button-variant-primary) {
	background: hsl(var(--primary));
}

:where(.Button-size-large) {
	padding: 0.75rem 1.5rem;
}
```

# Example Complete Component

```css
@layer common-components {
	:where(.Card) {
		box-sizing: border-box;
		position: relative;

		display: flex;
		flex-direction: column;

		padding: 1.5rem;
		border-radius: 0.5rem;
		border: 1px solid hsl(var(--border));

		background: hsl(var(--card));
		color: hsl(var(--card-foreground));

		box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1);
	}

	/* Variant: Elevated */
	:where(.Card-variant-elevated) {
		box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1);

		&:where(:hover) {
			box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1);
		}
	}

	/* Size: Compact */
	:where(.Card-size-compact) {
		padding: 1rem;
	}

	/* Size: Large */
	:where(.Card-size-large) {
		padding: 2rem;
	}
}
```

# Benefits of This Approach

- **Low specificity**: Easy to override styles when needed
- **Modern CSS**: Uses latest nesting and selector features
- **Maintainable**: Clear naming convention and organization
- **Performance**: Efficient CSS with minimal specificity conflicts
- **Scalable**: Consistent patterns across all components
- **Performance**: Efficient CSS with minimal specificity conflicts
- **Scalable**: Consistent patterns across all components
