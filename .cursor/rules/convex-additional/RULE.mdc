---
globs: packages/app/convex/**/*.ts
alwaysApply: false
---

Convex additional guidelines for this codebase.

# HTTP routes typing pattern (this repo)

This codebase defines HTTP routes using a “route builder” pattern that keeps runtime behavior and types in one place.

When you add or modify a Convex HTTP endpoint, follow this structure:

- Define routes inside a `*_http_routes(router)` function that **returns an object** shaped like:
  - `{ [pathLiteral]: { [methodLiteral]: { pathParams, searchParams, headers, body, response } } }`
- Use a **literal** `path` and **literal** `method` (usually via small IIFEs + `as const`) so TypeScript keeps them as exact strings.
- Use **computed keys** (`[path]`, `[method]`) so the returned object is keyed by the exact path/method.
- Implement a local `handler` function that returns `{ status, body, headers? }`.
- Register the real endpoint with `router.route({ path, method, handler: httpAction(...) })`.
- For the type schema, return a typed object whose `response` is derived from the handler:
  - `response: api_schemas_BuildResponseSpecFromHandler<typeof handler>`

Why this is type-safe:

- `api_schemas_Main` is built from `ReturnType<typeof *_http_routes>[path]`, so the schema is inferred from the route definitions.
- The `response` type is inferred from what the handler can return (status/body/headers), so changing the handler automatically updates the API types.

## Example (template)

```ts
export function example_http_routes(router: RouterForConvexModules) {
	return {
		...((/* iife */ path = "/api/example" as const satisfies api_schemas_Main_Path) => ({
			[path]: {
				...((/* iife */ method = "POST" as const) => ({
					[method]: ((/* iife */) => {
						// 1) Define the request/response types in one place
						type SearchParams = never;
						type PathParams = never;
						type Headers = Record<string, string>;
						type Body = { message: string };

						// 2) Implement the actual handler (runtime behavior)
						const handler = async (_ctx: ActionCtx, _request: Request) => {
							return {
								status: 200,
								body: { ok: true as const },
							} as const;
						};

						// 3) Register the endpoint in Convex
						router.route({
							path,
							method,
							handler: httpAction(async (ctx, request) => {
								const result = await handler(ctx, request);
								return Response.json(result.body, result);
							}),
						});

						// 4) Return a type-only descriptor used by `api_schemas_Main`
						return {} as {
							pathParams: PathParams;
							searchParams: SearchParams;
							headers: Headers;
							body: Body;
							response: api_schemas_BuildResponseSpecFromHandler<typeof handler>;
						};
					})(),
				}))(),
			},
		}))(),
	};
}
```

# Errors as values (`Result`) in Convex handlers

This repository uses an errors-as-values pattern (`Result`) in many Convex helpers and handlers.

When a Convex function returns a Result-like payload, the `returns` validator must describe both branches:

- `_yay` success object
- `_nay` error object (API-safe shape, usually `{ name, message }`)

Example:

```ts
export const create_page = mutation({
	args: { name: v.string() },
	returns: v.union(
		v.object({ _yay: v.object({ pageId: v.id("pages") }) }),
		v.object({ _nay: v.object({ name: v.string(), message: v.string() }) }),
	),
	handler: async (ctx, args) => {
		const page = await do_create_page(ctx, args);
		if (page._nay) {
			return page;
		}
		return Result({ _yay: { pageId: page._yay } });
	},
});
```

When calling Result-returning helpers:

- Do not ignore the return value.
- Bubble `_nay` when possible.
- If bubbling is not possible at that boundary, at least log `_nay` with context.

When throwing because of `_nay`, do not throw `_nay.message` directly.
Throw an ad hoc message and pass `_nay` via `cause`:

```ts
if (result._nay) {
	throw new Error("[OwnerSymbol.operation] Failed to create page", {
		cause: result._nay,
	});
}
```

## Warning about early returns after DB writes

This applies to any mutation flow, not only errors-as-values:

- Any normal return (including `_nay`, `null`, `{ error: ... }`, etc.) does **not** rollback prior writes in that mutation.
- Keep validation/fallible non-DB work first, and group DB writes at the end.
- Avoid early returns between related DB writes unless partial writes are explicitly intended.
- If a failure branch must rollback all writes, `throw` (prefer `ConvexError` for expected app-level failures).
- Exception: explicit cleanup markers in `finally` can be intentional side effects; document this clearly.

## Type-safe `ConvexError` pattern (this repo)

For thrown `ConvexError` typing, we attach error metadata to mutation args and extract it on the client.

Server side (in the mutation file):

```ts
function restore_snapshot_error() {
	return {
		_errors: v.optional(v.object({ message: v.literal("yjsSnapshotUpdates is not set") })),
	};
}

export const restore_snapshot = mutation({
	args: {
		// ...real args
		...({} as ReturnType<typeof restore_snapshot_error>),
	},
	handler: async (ctx, args) => {
		throw new ConvexError("yjsSnapshotUpdates is not set" satisfies NonNullable<(typeof args)["_errors"]>["message"]);
	},
});
```

Client side:

- Import `app_convex_Error` from `@/lib/app-convex-client.ts`.
- Narrow caught errors with `instanceof ConvexError`.
- Compare against a typed literal using `satisfies app_convex_Error<typeof app_convex_api.module.fn>["message"]`.

# Migrations

When the user asks for a Convex migration, you must implement it as an `internalMutation` in [../../../packages/app/convex/migrations.ts](../../../packages/app/convex/migrations.ts).

Keep migrations safe and repeatable:

- Always include `args` and `returns` validators.
- Prefer indexes (`withIndex`) over table scans. If you must scan, keep it small and return counts.
- Delete related records first, then delete the parent record.
- Do not rely on querying `undefined` from Convex. If you need “missing optional field” logic, collect and filter in JS.
- Return a small summary object (counts) so the user can verify what changed.
