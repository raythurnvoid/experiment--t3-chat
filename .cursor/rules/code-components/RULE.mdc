---
globs: packages/**/src/**/*.tsx, packages/**/src/**/*-hooks.ts, packages/**/src/**/use-*.ts
alwaysApply: false
---

React Components Guidelines

# React Compiler (this project)

This project uses the React Compiler.

## Core mental model

When you are writing components/hooks, you must assume:

- Values computed inside a component are memoized and reused until their automatically tracked dependencies change.
- Functions/closures created inside a component are memoized and reused until their automatically tracked dependencies change.
- You must not assume "everything is recomputed every render".

## Practical guidelines

### Avoid premature memoization

Do not add `useMemo` / `useCallback` just to avoid recomputation or to stabilize identities. Prefer plain expressions and inline callbacks.

Only add `useMemo` / `useCallback` when there is a concrete semantic requirement that cannot rely on the compiler (e.g. bridging to non-React APIs that store identities and must not be re-registered), and include a short comment explaining why it is required.

### Avoid derived-state effects

Do not use `useEffect` to keep derived state in sync.

Prefer computing derived values during render and returning them directly.

### Effects are still valid for real side-effects

Use `useEffect` (or other effect hooks) only for real side effects such as:

- Subscriptions/unsubscriptions to external systems
- Timers/intervals
- Imperative DOM APIs
- Bridging to non-React code

When you need a stable callback that can read the latest values without causing re-subscribe churn, prefer patterns like `useEffectEvent` or a "live ref" helper (as used in this codebase).

## Review checklist

When reviewing or proposing changes, you must question any newly introduced:

- `useEffect` (is this a real side effect, or derived state?)
- `useMemo` / `useCallback` (is this actually required, given React Compiler memoization?)

# Event-driven, centralized UI logic (preferred)

Prefer an **event-driven** style where data flows down and events flow up, keeping components linear and predictable.

- **Prefer explicit events over sync effects**: update state as a direct result of user/actions/events (e.g. `onSubmit`, `onSelect`, `onToggle`) rather than `useEffect`-based syncing.
- **Centralize side effects and integrations**: keep data fetching, mutations, and other side-effectful work in a stable “owner” layer (route/container/controller hook). Leaf components should be mostly presentational.
- **Prop-drill state + handlers**: children receive derived values and callbacks; avoid reintroducing contexts/hooks in leaves that duplicate wiring and hide dependencies.
- **Don’t leak query arguments to leaves**: for Convex (and similar), prefer that leaf components receive _data_, not the parameters used to fetch it; this reduces surprising cache/lifecycle issues when leaves unmount.
- **Prefer reset via re-mount over effect syncing**: when a leaf needs to “reset” on a key change (e.g. thread switch), prefer keying/remounting or passing an `initialValue`, not a store→leaf `useEffect` sync.

# Component Declaration

## Props Parameter Pattern

Use a single `props` parameter and destructure on the first line; keep `...rest` last to forward DOM-compatible props. This preserves access to the full `props` object for debugging/conditional logic, enables flexible prop forwarding, and allows conditional destructuring or passing the entire props object when needed.

The following rules are mandatory across this codebase:

## Do

- Use named function declarations for components.
- For components that accept props: accept a single `props` parameter; destructure on the first line inside the function body.
- For propsless components: do not add an empty `props` arg or empty props type; omit the parameter.
- Keep `...rest` last and forward DOM-compatible props as needed.
- Prefix all CSS classes with the component name.
- Use camelCase for props and all local symbols.
- Inside components, use arrow functions for all helpers/handlers (avoid hoisted `function` declarations).
- Use React 19 ref patterns: accept `ref` as a regular prop; prefer a callback ref with `forward_ref` to forward refs to children or multiple targets; use `useImperativeHandle` only to expose a custom imperative API.

## Don't

- Use `React.FC` or `FC`.
- Wrap components with `React.memo`.
- Destructure props in the function signature.
- Export anonymous arrow component expressions for top-level components.
- Use `function foo()` declarations inside components (they are hoisted; prefer `const foo = () => {}`).

## Prop Ordering

When destructuring component props, follow this exact order for named props, then place `...rest` last:

1. `ref` (if present)
2. `refs` (if present; can be aliased, e.g., `refs`)
3. `id`
4. `className`
5. Other props (domain-specific configuration flags, values, etc.)
6. Events (e.g., `onClick`, `onChange`, `onKeyDown`)
7. Named slots (ReactNode-like props such as `labelSlot`)
8. `children`

`...rest` must always be the final destructured item.

# Strict props by default (feature components)

When the user requests a new component, or when you edit an existing component, you must use a **strict API** by default.

## Required by default

Props must be required unless you have a clear reason to make them optional.

- Do not use `prop?: ...` unless the component works correctly when the prop is not provided.
- Do not “hide” required behavior with defaults in destructuring (for example `const { foo = "bar" } = props`) unless the user asked for that default.

## Model “absence” explicitly

If “missing” is part of the intended behavior, prefer `prop: T | null` (or a discriminated union) instead of `prop?: T | null`.

This makes the call-site explicit and avoids silent defaults.

## Exception: low-level reusable / technical components

Optional props are allowed when the component is a low-level reusable / technical building block used in many places (for example: a sentinel, a UI primitive, or shared infrastructure).

In those components:

- Optional props should have clear defaults.
- Keep the API small and stable across many use cases.

## Props Argument and Spread

- For components that accept props: the component function must accept a single argument named `props`.
- For propsless components: omit the parameter.
- Destructure at the top of the function; keep `...rest` last and spread it to the root DOM element when appropriate.

### Also applies to `_Props` type declarations

Use the same ordering when declaring fields in your `ComponentName_Props` interface. This applies to custom fields you declare; inherited DOM props from `extends React.ComponentProps<...>` are not re-ordered. Always put `children` last.

The comments should not be included in your generated code, they are only for documentation purposes.

```tsx
export type Example_Props = React.ComponentProps<"div"> & {
	ref?: Ref<HTMLDivElement>;
	id?: string;
	className?: string;
	// Other props
	variant?: "default" | "compact";
	// Events
	onClick?: React.MouseEventHandler<HTMLDivElement>;
	// Named slots
	headerSlot?: React.ReactNode;
	// Children last
	children?: React.ReactNode;
};
```

## Example

```tsx
export type Toolbar_Props = React.ComponentProps<"div"> & {
	ref?: Ref<HTMLDivElement>;
	id?: string;
	className?: string;
	variant?: "default" | "compact"; // other prop
	onClick?: React.MouseEventHandler<HTMLDivElement>; // event
	labelSlot?: React.ReactNode; // named slot
	children?: React.ReactNode;
};

export function Toolbar(props: Toolbar_Props) {
	const { ref, id, className, variant = "default", onClick, labelSlot, children, ...rest } = props;

	return (
		<div
			id={id}
			ref={ref}
			className={cn("Toolbar", `Toolbar-variant-${variant}`, className)}
			onClick={onClick}
			{...rest}
		>
			{labelSlot}
			{children}
		</div>
	);
}
```

# Component Styles

- Declare a `_ClassNames` union type enumerating all CSS class strings. Class values are prefixed with the main component name and use kebab-case for words. **Always include a root class whose value equals the component name (even if no styles are needed)** so the component is identifiable in HTML. This is especially important for debugging: having a unique class name on each component makes it easy to recognize and inspect components in the DOM using browser DevTools, even when the component doesn't have custom styles yet.

```ts
type Thread_ClassNames = "Thread" | "Thread-header" | "Thread-actions";
```

- **MANDATORY**: Use TypeScript's `satisfies` operator to validate component-owned class string literals at call sites.

```ts
<div className={cn("Thread" satisfies Thread_ClassNames)} />
```

- **MANDATORY**: Extend the same “typed string literal contract” approach beyond `className`:
  - **DOM ids**
    - When referencing DOM elements by id, validate the string with the app’s id types (e.g. `AppElementId`, `AppDomId`) using `satisfies`.
  - **`data-*` attributes**
    - Model component-owned `data-*` attributes as a `ComponentName_CustomAttributes` type and validate both the attribute usage and key access using `satisfies` / `ExtractStrict` as needed.

```ts
// DOM ids
document.getElementById("app_tiptap_hoisting_container" satisfies AppElementId);

// data-* attributes (example pattern)
type MyComponent_CustomAttributes = { "data-my-flag": "" };

el?.getAttribute("data-my-flag" satisfies ExtractStrict<keyof MyComponent_CustomAttributes, "data-my-flag">);
```

## Grouped \_ClassNames by Compound Component

Instead of a single `<ComponentName>_ClassNames` union, group class names by compound component. Each subcomponent gets its own `_ClassNames` type. Use PascalCase for subcomponent root classes and dash-suffixed modifiers for states, variants, and sizes.

**Type Placement**: Each `_ClassNames` type must be placed directly above its corresponding component definition, before any `_Props` or `_Ref` types.

**Reusing Styles from Other Components**: When a component needs to reuse styling from another `my-*` component, import the other component's `_ClassNames` type and apply both the component's own class name and the reused class name. This maintains component identity for debugging while inheriting shared styles. For example:

```tsx
import type { MyInputArea_ClassNames, MyInputControl_ClassNames } from "./my-input.tsx";

export type MyComboboxInputArea_ClassNames = "MyComboboxInputArea";

export function MyComboboxInputArea(props: MyComboboxInputArea_Props) {
	const { className, children, ...rest } = props;
	return (
		<div
			className={cn(
				"MyComboboxInputArea" satisfies MyComboboxInputArea_ClassNames,
				"MyInputArea" satisfies MyInputArea_ClassNames,
				className,
			)}
			{...rest}
		>
			{children}
		</div>
	);
}
```

This pattern ensures that:

1. The component has its own identifiable class name (`MyComboboxInputArea`) for debugging
2. The component inherits styles from the reused component (`MyInputArea`)
3. Both class names are type-checked using `satisfies` for safety

```tsx
export type Thread_ClassNames = "Thread";

export type Thread_Props = React.ComponentProps<"div"> & {
	children?: React.ReactNode;
};

export function Thread(props: Thread_Props) {
	const { className, children, ...rest } = props;
	return (
		<div className={cn("Thread" satisfies Thread_ClassNames, className)} {...rest}>
			{children}
		</div>
	);
}

export type ThreadHeader_ClassNames = "ThreadHeader" | "ThreadHeader-title";

export type ThreadHeader_Props = React.ComponentProps<"div"> & {
	title?: string;
};

export function ThreadHeader(props: ThreadHeader_Props) {
	const { className, title, ...rest } = props;
	return (
		<div className={cn("ThreadHeader" satisfies ThreadHeader_ClassNames, className)} {...rest}>
			{title && <h2 className={cn("ThreadHeader-title" satisfies ThreadHeader_ClassNames)}>{title}</h2>}
		</div>
	);
}

export type ThreadMenuButton_ClassNames =
	| "ThreadMenuButton"
	| "ThreadMenuButton-variant-outline"
	| "ThreadMenuButton-variant-ghost"
	| "ThreadMenuButton-size-sm"
	| "ThreadMenuButton-size-lg";

export type ThreadMenuButton_Props = React.ComponentProps<"button"> & {
	variant?: "outline" | "ghost";
	size?: "sm" | "lg";
};

export function ThreadMenuButton(props: ThreadMenuButton_Props) {
	const { className, variant = "outline", size = "sm", ...rest } = props;
	return (
		<button
			className={cn(
				"ThreadMenuButton" satisfies ThreadMenuButton_ClassNames,
				variant === "outline" && ("ThreadMenuButton-variant-outline" satisfies ThreadMenuButton_ClassNames),
				variant === "ghost" && ("ThreadMenuButton-variant-ghost" satisfies ThreadMenuButton_ClassNames),
				size === "sm" && ("ThreadMenuButton-size-sm" satisfies ThreadMenuButton_ClassNames),
				size === "lg" && ("ThreadMenuButton-size-lg" satisfies ThreadMenuButton_ClassNames),
				className,
			)}
			{...rest}
		/>
	);
}
```

- Use Tailwind by default for styling. When the user requests explicit CSS classes, prefer component-prefixed classes validated by the `_ClassNames` type and follow the CSS rules in [airule-code-css](.cursor/rules/code-css/RULE.md).

- Variants and sizes must be represented directly in each component's `_ClassNames` type. Use conditional adds with `satisfies` for validation.

```ts
export type Button_ClassNames =
	| "Button"
	| "Button-variant-default"
	| "Button-variant-destructive"
	| "Button-variant-outline"
	| "Button-variant-ghost"
	| "Button-size-default"
	| "Button-size-sm"
	| "Button-size-lg"
	| "Button-size-icon";

export function Button(
	props: {
		className?: string;
		variant?: "default" | "destructive" | "outline" | "ghost" | null;
		size?: "default" | "sm" | "lg" | "icon";
	} & React.ComponentProps<"button">,
) {
	const { className, variant = "default", size = "default", ...rest } = props;
	return (
		<button
			className={cn(
				"Button" satisfies Button_ClassNames,
				variant === "default" && ("Button-variant-default" satisfies Button_ClassNames),
				variant === "destructive" && ("Button-variant-destructive" satisfies Button_ClassNames),
				variant === "outline" && ("Button-variant-outline" satisfies Button_ClassNames),
				variant === "ghost" && ("Button-variant-ghost" satisfies Button_ClassNames),
				size === "default" && ("Button-size-default" satisfies Button_ClassNames),
				size === "sm" && ("Button-size-sm" satisfies Button_ClassNames),
				size === "lg" && ("Button-size-lg" satisfies Button_ClassNames),
				size === "icon" && ("Button-size-icon" satisfies Button_ClassNames),
				className,
			)}
			{...rest}
		/>
	);
}
```

## Component CSS Variables (\_CssVars)

Use a `<ComponentName>_CssVars` type to model component-scoped CSS custom properties and provide defaults merged into the `style` prop. Spread defaults first, then user `style` so the user can override defaults.

```tsx
export type Thread_ClassNames = "Thread" | "Thread-header" | "Thread-actions";

export type Thread_CssVars = {
	"--thread-width": string;
	"--thread-width-collapsed": string;
};

const Thread_CssVars_DEFAULTS: Partial<Thread_CssVars> = {
	"--thread-width": "320px",
	"--thread-width-collapsed": "48px",
} as const;

export type Thread_Props = React.ComponentProps<"aside"> & {
	style?: React.CSSProperties & Partial<Thread_CssVars>;
	width?: string;
	widthCollapsed?: string;
};

export function Thread(props: React.ComponentProps<"aside">) {
	const { className, style, width, widthCollapsed, ...rest } = props;
	return (
		<aside
			className={cn("Thread" satisfies Thread_ClassNames, className)}
			style={{
				...({
					...Thread_CssVars_DEFAULTS,
					"--thread-width": width ?? Thread_CssVars_DEFAULTS["--thread-width"],
					"--thread-width-collapsed": widthCollapsed ?? Thread_CssVars_DEFAULTS["--thread-width-collapsed"],
				} satisfies Partial<Thread_CssVars>),
				...style,
			}}
			{...rest}
		/>
	);
}
```

- Prefer overriding specific properties via `className` over custom positioning. Fall back to custom CSS only when necessary.

## className and style utilities

Use `cn` from `@/lib/utils.ts` to merge class names, and `sx` for style objects:

When only a single static class is being used and `className` is not being forwarded/merged, prefer a plain string (optionally with `satisfies`) over wrapping it in `cn(...)`. If you notice existing instances of `cn("SingleClass")`, do not refactor them just to remove `cn`, but also do not introduce new single-class `cn(...)` usages proactively.

```ts
import { cn, sx } from "@/lib/utils.ts";

// className merging with cn
<div
	className={cn(
		"base-class" satisfies MyComponent_ClassNames,
		className,
		condition && "conditional-class",
	)}
/>

// style objects with sx (especially useful for CSS custom properties)
<div
	style={sx({ "--MyComponent-custom-var": value } satisfies Partial<MyComponent_CssVars>)}
/>
```

# Advanced interactive components patterns

## List rows: primary action + secondary actions (overlay grid + subgrid)

Use this pattern for list rows where:

- The row should be clickable as a single **primary action** (open/select).
- The row also has **secondary icon actions** (star/archive/rename, etc.).
- The row highlight on hover should match the primary click target (no “dead” padding).
- The primary label must never go underneath the actions (proper truncation).

### Core idea

- The row container is a 2-column grid: `1fr auto` (content + actions).
- The **primary action element** spans the full row and uses `subgrid` so it “inherits” the same column layout as the row.
- The **actions container** sits in the right column and intercepts clicks in the actions area, so clicking between action buttons does not trigger the primary action.

### CSS template

```css
.Row {
	display: grid;
	grid-template-columns: 1fr auto;
	align-items: center;

	border: 1px solid transparent; /* enables :focus-within border affordance */
}

.Row-primary {
	grid-column: 1 / -1;
	grid-row: 1;

	display: grid;
	grid-template-columns: subgrid;
	align-items: center;

	height: 36px; /* match action button height */
	padding: 0 12px; /* row padding belongs here */
}

.Row-title {
	grid-column: 1;
	min-width: 0;

	overflow: hidden;
	text-overflow: ellipsis;
	white-space: nowrap;
}

.Row-actions {
	grid-column: 2;
	grid-row: 1;

	display: flex;
	align-items: center;
	gap: 4px;

	/* Keep pointer-events enabled so clicks in this zone don't hit .Row-primary */
	pointer-events: auto;
}
```

### Interaction guidance

- Prefer a single row-level focus affordance: `.Row:focus-within { border-color: ... }` so the whole row reads as “focused”.
- Apply hover/selected backgrounds to `.Row` (not the primary button) so the visual highlight includes the actions area too.
- Use a shared icon button component for secondary actions (e.g. `MyIconButton`/`MyIconButtonIcon`) to keep hover/focus colors consistent.

# React 19 Context Patterns

## Modern Context with use Hook

**MANDATORY**: Use React 19's `use` hook instead of `useContext` for consuming context.

### Context Setup Pattern:

```tsx
import { createContext, use, useState, ReactNode } from "react";

// Context interface with camelCase for internal state
interface SearchContextType {
	searchQuery: string;
	isLoading: boolean;
	setSearchQuery: (query: string) => void;
	setIsLoading: (loading: boolean) => void;
}

const SearchContext = createContext<SearchContextType | null>(null);

// Custom hook using React 19 'use' hook
const useSearchContext = () => {
	const context = use(SearchContext);
	if (!context) {
		throw new Error("useSearchContext must be used within SearchContextProvider");
	}
	return context;
};

// Provider component with camelCase state
function SearchContextProvider(props: { children: ReactNode }) {
	const { children } = props;
	const [searchQuery, setSearchQuery] = useState("");
	const [isLoading, setIsLoading] = useState(false);

	return (
		<SearchContext.Provider
			value={{
				searchQuery,
				setSearchQuery,
				isLoading,
				setIsLoading,
			}}
		>
			{children}
		</SearchContext.Provider>
	);
}
```

# Refs and useImperativeHandle

## Ref as a regular prop

You must pass `ref` as a regular prop without `forwardRef`:

```tsx
// ✅ React 19: ref as regular prop (new way)
export interface Button_Props {
	ref?: Ref<HTMLButtonElement>;
	children: React.ReactNode;
}

export function Button(props: Button_Props) {
	const { ref, children, ...rest } = props;

	return (
		<button ref={ref} {...rest}>
			{children}
		</button>
	);
}
```

## Callback Refs with Cleanup Functions

Callback refs can return cleanup functions:

```tsx
function ResizeObserverComponent(props: ResizeObserverComponent_Props) {
	const { onResize } = props;
	const [height, setHeight] = useState(0);

	const measuredRef = (node: HTMLDivElement | null) => {
		if (!node) return;

		const observer = new ResizeObserver(([entry]) => {
			setHeight(entry.contentRect.height);
			onResize?.(entry.contentRect.height);
		});

		observer.observe(node);

		// Return cleanup function
		return () => {
			observer.disconnect();
		};
	};

	return <div ref={measuredRef}>Height: {Math.round(height)}px</div>;
}
```

## Forwarding refs to children

Use a callback ref with the `forward_ref` helper to forward the instance to the parent `ref` and any internal refs.

```tsx
import { forward_ref } from "@/lib/utils.ts";

function Parent(props: { ref?: React.Ref<any> }) {
	const { ref } = props;
	const childRef = useRef<any>(null);

	return (
		<Child
			ref={(inst) => {
				return forward_ref(inst, ref, childRef);
			}}
		/>
	);
}
```

You can also use `forward_ref` to forward the same instance to a `setState` function (for example, store a DOM node in state so you can pass it as an `IntersectionObserver` root).

```tsx
import { forward_ref } from "@/lib/utils.ts";

function Example() {
	const divRef = useRef<HTMLDivElement | null>(null);
	const [root, setRoot] = useState<HTMLDivElement | null>(null);

	return <div ref={(node) => forward_ref(node, divRef, setRoot)} />;
}
```

## Imperative handle pattern

```tsx
import React, { useImperativeHandle, useRef, useState, Ref } from "react";

export interface MyWidget_Ref {
	rootElement: HTMLDivElement | null;
	focusInput: () => void;
	getValue: () => string;
}

export type MyWidget_Props = React.ComponentProps<"div"> & {
	ref?: Ref<MyWidget_Ref>;
	initialValue?: string;
};

export function MyWidget(props: MyWidget_Props) {
	const { ref, initialValue = "", className, ...rest } = props;
	const rootRef = useRef<HTMLDivElement>(null);
	const inputRef = useRef<HTMLInputElement>(null);
	const [value, setValue] = useState(initialValue);

	useImperativeHandle(
		ref,
		() => ({
			rootElement: rootRef.current,
			focusInput: () => inputRef.current?.focus(),
			getValue: () => value,
		}),
		[value],
	);

	return (
		<div ref={rootRef} className={cn("MyWidget", className)} {...rest}>
			<input ref={inputRef} value={value} onChange={(e) => setValue(e.target.value)} className={cn("MyWidget-input")} />
		</div>
	);
}
```

## Exposing multiple elements via a single ref

```tsx
import React, { useImperativeHandle, useRef, Ref } from "react";

export interface Drawer_Ref {
	root: HTMLDivElement | null;
	header: HTMLElement | null;
	scrollContainer: HTMLDivElement | null;
}

export type Drawer_Props = React.ComponentProps<"div"> & {
	ref?: Ref<Drawer_Ref>;
};

export function Drawer(props: Drawer_Props) {
	const { ref, className, ...rest } = props;
	const rootRef = useRef<HTMLDivElement>(null);
	const headerRef = useRef<HTMLElement>(null);
	const scrollRef = useRef<HTMLDivElement>(null);

	useImperativeHandle(
		ref,
		() => ({
			root: rootRef.current,
			header: headerRef.current,
			scrollContainer: scrollRef.current,
		}),
		[],
	);

	return (
		<div ref={rootRef} className={cn("Drawer", className)} {...rest}>
			<header ref={headerRef} className={cn("Drawer-header")} />
			<div ref={scrollRef} className={cn("Drawer-scroll-container")} />
		</div>
	);
}
```

## Use `useRef` When:

- Simple element access
- Non-reactive values that don't trigger re-renders
- Storing timers, intervals, or other imperative handles

```tsx
// ✅ Object ref for simple access
const inputRef = useRef<HTMLInputElement>(null);

const focusInput = () => {
	inputRef.current?.focus();
};
```

### useRef with setTimeout and setInterval

Store timer IDs in a ref to manage cleanup

```tsx
import { useRef, useEffect } from "react";

export function MyComponent(props: MyComponent_Props) {
	// ... eventually props and other state

	const timerRef = useRef<ReturnType<typeof setTimeout>>(null);

	const startTimer = () => {
		if (timerRef.current) {
			clearTimeout(timerRef.current);
		}

		timerRef.current = setTimeout(() => {
			// ... task implementation
		}, 1000);
	};

	// ... rest of the component
}
```

# React effect event patterns (useEffectEvent)

Use `useEffectEvent` when you need a stable callback that can read the latest state/props without forcing effects, subscriptions, or observers to re-run on every render.

## Use it for freshness without deps/ref churn

- Use `useEffectEvent` for handlers passed into observers/subscriptions/timers where you do not want to re-subscribe on every render.\n- Do not add refs purely for freshness; the event callback reads the latest values.\n- Still use `useRef` for imperative handles (DOM nodes, timers, observers).

```tsx
import { useEffect, useEffectEvent } from "react";

export function Example(props: { value: string }) {
	const { value } = props;

	const logLatest = useEffectEvent(() => {
		console.log("latest value:", value);
	});

	useEffect(() => {
		const id = setInterval(() => logLatest(), 1000);
		return () => clearInterval(id);
	}, [logLatest]);

	return null;
}
```

# Component attached exports (Fast Refresh / HMR-friendly)

Sometimes we want a “single module” that conceptually exports multiple symbols (component, hooks, constants), but React Fast Refresh / HMR can behave poorly with extra top-level exports.

In those cases, **attach the extra symbols as properties on the component** via dot-notation assignments. This keeps leaf imports ergonomic and avoids scattering context/hooks across multiple modules.

- Prefer `MyContextProvider.useContext` over a separate `export function useMyContext()`.
- Attach only _stable_ helpers/hooks/constants that are conceptually owned by the component.

```tsx
export function MyContextProvider(props: MyContextProvider_Props) {
	// ...
	return props.children;
}

MyContextProvider.useContext = function useContext() {
	// ... read context ...
	return {};
};

MyContextProvider.DEFAULTS = {
	// ... constants ...
} as const;
```

If TypeScript complains about missing properties on the function, add a **type-only** declaration for the attached fields (no runtime export):

```ts
declare namespace MyContextProvider {
	export const DEFAULTS: typeof MyContextProvider.DEFAULTS;
	export const useContext: typeof MyContextProvider.useContext;
}
```

# Component Region Wrapping

Region wrapping is recommended for large modules (especially multi-component modules) but is not a strict requirement.
If the user requests regions for a module, wrap each component and its related types in VS Code region markers.

## Region label style must match the module

You must use the same region label style already used in that module.

- If the module uses topic-based, lowercase labels (example: `message`, `message list`, `thread`, `root`), keep using that style.
- Do not introduce PascalCase region labels (example: `ComponentName`) into modules that use lowercase topic labels.

## Keep TSX and CSS region names aligned

If a `.tsx` module has a paired `.css` file, the `/* #region ... */` labels in the CSS must match the `// #region ...` labels in the TSX.

## Placement

Place `// #region <label>` before the types/helpers for that section, and `// #endregion <label>` after the related component/function body.

Many modules include several compound components that already share an obvious prefix (for example, `PageEditorRichTextInner`,
`PageEditorRichTextToolbar`, `PageEditorRichTextBubble`). Repeating the full prefix in every region label adds noise without
improving clarity. In those cases, you may shorten the region label to the specific component name required to identify the section
(`// #region Toolbar`, `// #region Bubble`, etc.). Always choose the shortest label that still makes it obvious which component and
types are wrapped.

```tsx
// #region ComponentName
type ComponentName_ClassNames = "ComponentName";
type ComponentName_Props = React.ComponentProps<"div"> & { children?: React.ReactNode };

function ComponentName(props: ComponentName_Props) {
	const { children, ...rest } = props;
	return <div {...rest}>{children}</div>;
}
// #endregion ComponentName
```

# Find the right place to insert new code

When editing an existing `.tsx` file, you must first understand the file’s structure and place changes in the most appropriate location.

## Required pre-scan

Before inserting code, you must scan the file for (at minimum):

- Existing `// #region ...` / `// #endregion ...` markers
- Imports/exports and any module-level constants
- Existing ordering patterns (types → helpers → handlers → components, etc.)

## Placement rules

- If the file uses regions, you must add new code **inside the most relevant existing region**, adjacent to similar code (do not create a new region unless the file already does so as a pattern).
- If there are no regions, insert immediately above/below the nearest similar symbol or first call-site.
- Avoid dumping new helpers/types at the very top or bottom; match the file’s local organization.
