---
description: Global project guidelines covering package management, terminal usage, code quality, code organization, casing conventions, and complete application architecture
alwaysApply: true
---

Global rules for the project.

# Package manager

This repository uses `pnpm` do not use `npm`.

# Running commands in the terminal

Do not run `pnpm run dev` let the user run it manually.

# Terminal and Shell Command Behavior

## Default Terminal Location

IMPORTANT: When terminals are opened in this workspace, they start in the [packages/app/](mdc:packages/app) directory by default, NOT the workspace root.

This means:

- Terminal commands run relative to `packages/app/` unless explicitly navigated elsewhere
- File paths in terminal commands should account for this starting location
- The `packages/app/` directory contains the main application code

## Navigating to Root When Needed

```bash
# Navigate to workspace root from packages/app/
cd ../..

# Or use relative paths from packages/app/
../../pnpm-workspace.yaml
```

## Common Scenarios Requiring Root Navigation

- Accessing workspace configuration files like [pnpm-workspace.yaml](mdc:pnpm-workspace.yaml)
- Managing monorepo-level dependencies
- Running workspace-level commands (e.g., `pnpm install` at root level)
- Accessing files outside the `packages/app/` directory
- Working with the [+personal/](mdc:+personal) folder or other root-level directories

## Path Reference Examples

From default terminal location (`packages/app/`):

- Main app code: `./src/` or `src/` (current directory)
- Convex backend: `./convex/` or `convex/`
- Workspace root: `../../`
- Package.json at root: `../../package.json`
- Other packages: `../other-package/`

# Code Quality and Linting

Do not run commands to verify lints or check code quality (such as `pnpm lint`, `pnpm type-check`, or similar commands). Instead, rely only on the information that Cursor automatically provides through its built-in linting and error detection.

You can run linting commands only if the user explicitly requests it.

# Project Structure and Key Directories

## Monorepo Structure

This is a monorepo project with the following essential structure that you must always be aware of:

- [package.json](mdc:package.json) - Root package configuration
- [pnpm-workspace.yaml](mdc:pnpm-workspace.yaml) - Workspace configuration for the monorepo
- [pnpm-lock.yaml](mdc:pnpm-lock.yaml) - Lockfile for all dependencies

## Folders organization

- [packages/app/](mdc:packages/app) - MAIN APPLICATION ROOT
  - [src/](mdc:packages/app/src) - React frontend application code
    - [src/components/](mdc:packages/app/src/components) - React components (UI, assistant-ui, canvas)
    - [src/routes/](mdc:packages/app/src/routes) - TanStack Router route definitions
    - [src/lib/](mdc:packages/app/src/lib) - Shared utilities and helpers
    - [src/hooks/](mdc:packages/app/src/hooks) - Custom React hooks
    - [src/stores/](mdc:packages/app/src/stores) - State management (Zustand stores)
    - [src/types/](mdc:packages/app/src/types) - TypeScript type definitions
    - [src/app.css](mdc:packages/app/src/app.css) - Main CSS file with Tailwind 4 configuration
  - [convex/](mdc:packages/app/convex) - Convex backend code and functions
  - [shared/](mdc:packages/app/shared) - Shared code between frontend and backend
  - [vendor/assistant-ui/](mdc:packages/app/vendor/assistant-ui) - Assistant UI submodule (full repo for reference)
  - [vendor/liveblocks/](mdc:packages/app/vendor/liveblocks) - Liveblocks submodule (full repo for reference)
  - [vendor/ai/](mdc:packages/app/vendor/ai) - AI SDK submodule (full repo for reference)
  - [vendor/opencode/](mdc:packages/app/vendor/opencode) - OpenCode development platform submodule (full repo for reference)

- [+personal/](mdc:+personal) - DOCUMENTATION & RESEARCH FOLDER
  - Contains files useful for answering questions and resolving complex problems
  - Includes 3rd party codebases and documentation for research purposes
  - Examples: React Complex Tree, AI SDK, BlockNote, shadcn, TanStack Router sources
  - [+personal/+ai/](mdc:+personal/+ai) - Only writable subfolder for AI-generated content
  - DO NOT MODIFY other files in +personal/ - they are reference material only

## Submodules (Special Import Handling)

- [packages/app/vendor/assistant-ui/](mdc:packages/app/vendor/assistant-ui) - Assistant UI submodule with custom overrides
  - Importing: Import directly from the submodule (NOT from node_modules)
    - Correct:
      ```ts
      import { useAssistantTool } from "@/vendor/assistant-ui/packages/react/src/runtime";
      import { ThreadWelcome } from "@/vendor/assistant-ui/packages/react/src/ui/thread-welcome";
      ```
  - Documentation folders:
    - [apps/docs/](mdc:packages/app/vendor/assistant-ui/apps/docs)
  - Examples folders:
    - [examples/](mdc:packages/app/vendor/assistant-ui/examples)

- [packages/app/vendor/liveblocks/](mdc:packages/app/vendor/liveblocks) - Liveblocks submodule
  - Importing: Use standard node_modules imports in the app, submodule is for reference
    - Correct:
      ```ts
      import { LiveblocksProvider } from "@liveblocks/react";
      ```
  - Documentation folders:
    - [docs/](mdc:packages/app/vendor/liveblocks/docs)
    - [guides/](mdc:packages/app/vendor/liveblocks/guides)
    - [tutorial/](mdc:packages/app/vendor/liveblocks/tutorial)
  - Examples folders:
    - [examples/](mdc:packages/app/vendor/liveblocks/examples)
    - [starter-kits/](mdc:packages/app/vendor/liveblocks/starter-kits)

- [packages/app/vendor/ai/](mdc:packages/app/vendor/ai) - AI SDK repository
  - Importing: Use standard node_modules imports in the app, submodule is for reference
  - Documentation folders:
    - [content/docs/](mdc:packages/app/vendor/ai/content/docs)
    - [content/providers/](mdc:packages/app/vendor/ai/content/providers)
  - Examples folders:
    - [examples/](mdc:packages/app/vendor/ai/examples)

- [packages/app/vendor/opencode/](mdc:packages/app/vendor/opencode) - OpenCode development platform submodule
  - Importing: Use standard node_modules imports in the app, submodule is for reference
  - Documentation folders:
    - [README.md](mdc:packages/app/vendor/opencode/README.md)
    - [AGENTS.md](mdc:packages/app/vendor/opencode/AGENTS.md)
  - Package folders:
    - [packages/](mdc:packages/app/vendor/opencode/packages)

## 3rd Party Documentation Research

When users ask about 3rd party libraries or request implementations using external dependencies, conduct thorough documentation research for accurate responses.

Documentation Sources

- [+personal/](mdc:+personal) - Contains source repos of complex dependencies
- [+personal/sources/vercel-ai-sdk-ui-ai-elements-docs/](mdc:+personal/sources/vercel-ai-sdk-ui-ai-elements-docs) - AI SDK AI Elements components documentation (specific UI component docs)
- Submodules - [packages/app/vendor/assistant-ui/](mdc:packages/app/vendor/assistant-ui), [packages/app/vendor/liveblocks/](mdc:packages/app/vendor/liveblocks), [packages/app/vendor/ai/](mdc:packages/app/vendor/ai), and [packages/app/vendor/opencode/](mdc:packages/app/vendor/opencode) have full repos for reference
- Web search - For external documentation when not available locally

Research Process

1. Find docs first - Look for `.md`, `.mdx`, `.txt`, and `docs/` folders
2. Read extensively - Multiple sections, examples, and guides until confident
3. Prioritize docs over source - Use source code only for complex edge cases
4. Understand thoroughly - Continue reading until no doubts remain
5. Look for examples - Prefer real code examples and usage patterns

Quality Standard: Understanding should be deep enough to explain concepts confidently and implement solutions without guessing. If uncertain, keep researching until clear.

### Configuration Files

- [packages/app/convex.json](mdc:packages/app/convex.json) - Convex configuration
- [packages/app/components.json](mdc:packages/app/components.json) - shadcn/ui component library configuration
- [packages/app/tsconfig.json](mdc:packages/app/tsconfig.json) - TypeScript configuration for the app
- [packages/app/index.html](mdc:packages/app/index.html) - HTML entry point for Vite
- [packages/app/vite.config.ts](mdc:packages/app/vite.config.ts) - Vite development server configuration

## Import Guidelines

### Assistant UI Imports

When importing assistant-ui components or utilities, ALWAYS import directly from the submodule:

```ts
// ✅ CORRECT - Import from submodule
import { useAssistantTool } from "@/vendor/assistant-ui/packages/react/src/runtime";
import { ThreadWelcome } from "@/vendor/assistant-ui/packages/react/src/ui/thread-welcome";

// ❌ WRONG - Do not import from node_modules
import { useAssistantTool } from "@assistant-ui/react";
```

### Standard Library Imports

For other libraries like Liveblocks, use standard node_modules imports:

```ts
// ✅ CORRECT - Standard import
import { LiveblocksProvider } from "@liveblocks/react";
```

# Code guidelines

You must not use `any` to bypass typescript errors unless the user is asking for it.

The code of the app is located at [packages/app/](mdc:packages/app).

Use tab indentation for `.ts`, `.tsx` and `.css` files.

## Object.assign Usage

When using `Object.assign`, always verify that arguments are not `undefined` before passing them to prevent unexpected behaviors and potential runtime errors.

✅ Correct Pattern

```ts
Object.assign(
	{
		updated_by: updated_by,
		updated_at: Date.now(),
	},
	args.title !== undefined ? { title: args.title } : {},
	args.is_archived !== undefined ? { archived: args.is_archived } : {},
);
```

❌ Problematic Pattern

```ts
Object.assign(
	{
		updated_by: updated_by,
		updated_at: Date.now(),
	},
	{
		title: args.title, // Could be undefined
		archived: args.is_archived, // Could be undefined
	},
);
```

# Application Architecture

This app is an AI chatbot that allows users to chat with AI, call tools, and produce documents in a canvas panel.

## Backend Architecture

The backend uses Convex as the primary backend platform, located in [packages/app/convex/](mdc:packages/app/convex):

- [ai_chat.ts](mdc:packages/app/convex/ai_chat.ts) - Main AI chat functionality with streaming, tool calling, and artifact creation
- [schema.ts](mdc:packages/app/convex/schema.ts) - Database schema for threads and messages
- [auth.ts](mdc:packages/app/convex/auth.ts) - Authentication with Clerk integration
- [http.ts](mdc:packages/app/convex/http.ts) - HTTP routing for API endpoints

The Convex backend handles:

- AI chat streaming with OpenAI integration
- Thread and message management
- Tool calling (weather, artifact creation)
- Authentication token generation
- CORS handling

## Frontend Architecture

The frontend is a React 19 application located in [packages/app/src/](mdc:packages/app/src):

- [main.tsx](mdc:packages/app/src/main.tsx) - Application entry point with providers
- [routes/](mdc:packages/app/src/routes) - TanStack Router route definitions
  - [\_\_root.tsx](mdc:packages/app/src/routes/__root.tsx) - Root layout with auth setup
  - [index.tsx](mdc:packages/app/src/routes/index.tsx) - Home page
  - [chat.tsx](mdc:packages/app/src/routes/chat.tsx) - Main chat interface with canvas
- [components/](mdc:packages/app/src/components) - React components organized by feature
  - [assistant-ui/](mdc:packages/app/src/components/assistant-ui) - Chat interface components
  - [canvas/](mdc:packages/app/src/components/canvas) - Canvas/artifact editing components
  - [ui/](mdc:packages/app/src/components/ui) - Shared UI components

## Key Technologies

- Convex - Backend platform with real-time database
- Clerk - Authentication provider
- Assistant UI - Chat interface components (submodule)
- Liveblocks - Real-time collaboration (submodule)
- BlockNote - Rich text editor for canvas/artifacts
- TanStack Router - File-based routing
- Tailwind 4 - Utility-first CSS framework
- React 19 - Frontend framework
- shadcn/ui - Component library with Tailwind styling
- React Complex Tree - Tree component for file/folder navigation
- AI SDK - AI integration and streaming utilities

## Technology Stack

This project uses the latest versions of core technologies:

- React 19
- Tailwind 4

### Tailwind Configuration

IMPORTANT: This project uses CSS-based Tailwind V4 configuration instead of `tailwind.config.js`:

- [packages/app/src/app.css](mdc:packages/app/src/app.css) - Main CSS file containing Tailwind configuration
- Tailwind is configured using CSS `@config` directive and CSS custom properties
- All theme customization, plugins, and configuration are handled in the CSS file

### Component Styling

- shadcn/ui components provide pre-styled, accessible components
- Components follow Tailwind utility patterns with CSS custom properties
- Design system tokens are defined in [packages/app/src/app.css](mdc:packages/app/src/app.css)

### Documentation Requirements

- Always reference React 19 documentation for React-specific features
- Always reference Tailwind 4 documentation for CSS utilities/config
- If encountering unfamiliar patterns or errors, prefer the latest docs

## Application Structure

The app runs at http://localhost:5173/ during development.

The app has two main views:

1. Home page (`/`) - Basic landing page with navigation
2. Chat page (`/chat`) - Split-panel interface with:
   - Left sidebar: Thread list and navigation
   - Center panel: Chat interface with AI conversation
   - Right panel: Canvas for editing artifacts and documents

## Data Flow

1. User interactions in the frontend trigger TanStack Router navigation
2. Chat messages are sent to Convex HTTP actions via Assistant UI runtime
3. Convex processes messages, calls OpenAI API, and streams responses
4. Tool calls can create artifacts that appear in the canvas panel
5. Thread and message data is persisted in Convex database
6. Authentication is handled by Clerk with Convex integration

# Convex Environment Variables

## Two URLs for Different Purposes

- VITE_CONVEX_URL - WebSocket/real-time (queries, mutations, subscriptions)
- VITE_CONVEX_HTTP_URL - HTTP actions (API endpoints, authentication)

## HTTP Request Configuration

Use centralized fetch utilities from [packages/app/src/lib/fetch.ts](mdc:packages/app/src/lib/fetch.ts) for internal HTTP requests.

For third-party integrations, construct URLs manually using `VITE_CONVEX_HTTP_URL`.

## Casing

Use snake_case only for symbols defined at the root of a module (except components and hooks). Everything else uses camelCase.

### Root Level Module Symbols (snake_case)

```ts
export const ai_chat_HARDCODED_PROJECT_ID = "app_project_local_dev";

export class ai_chat_MyClass {
	constructor(public projectId: string) {}
}

export interface ai_chat_MyInterface {
	projectId: string;
}

export type ai_chat_MyType = {
	projectId: string;
};

export function ai_chat_my_function(projectId: string) {
	const processedResult = processData(projectId);
	return processedResult;
}

export enum ai_chat_MyEnum {
	PROJECT_ID = "app_project_local_dev",
}
```

### Everything Else (camelCase)

```ts
function ai_chat_example_function() {
	const bodyResult = await request.json();
	const generationResult = await generateObject();
	const workspacePattern = `${orgId}:${projectId}:*`;

	const processData = (inputValue: string, optionFlags: boolean) => {
		return {
			processedValue: inputValue,
			isComplete: optionFlags,
		};
	};
}
```

### Components and Hooks (Exceptions)

Components use PascalCase, hooks use camelCase:

```ts
export function ThemeProvider() {}
export function MessageComposer() {}
export function useTheme() {
	return { mode: "light", resolvedTheme: "light", setMode: () => {} };
}
export function useAiChat_grouped_threads() {
	const threadGroups = useMemo(() => {}, []);
	return threadGroups;
}
```

### Third-Party and Native JavaScript Functions

If a function is imported as camelCase, keep it as-is:

```ts
import { randomUUID } from "node:crypto";
const uuid = randomUUID();
window.matchMedia("(prefers-color-scheme: dark)").matches;
```

# Use Playwright

When performing frontend changes, you can use Playwright tools to verify your changes and ensure the UI meets the user's requirements.

Verification Workflow

1. Take snapshots to understand the current page structure and navigate it properly
2. Capture screenshots to verify if the UI changes match the user's requests
