---
description: Guidelines for creating and styling React components, including class naming patterns, semantic classnames, and component organization
globs: packages/**/src/components/**/*.tsx
alwaysApply: false
---

React Components Guidelines

# Understanding Component Styles First

## Critical: Read Component Styles Before Custom Solutions

**MANDATORY**: When working with component libraries (especially shadcn/ui), always understand the existing component styles before implementing custom solutions.

### Process for Styling Issues:

1. **Inspect the component's default CSS** - Understand what margins, padding, positioning the component uses by default
2. **Identify specific style properties** that need adjustment
3. **Override specific properties** using className props rather than creating custom solutions
4. **Only resort to custom positioning/styling** if working with existing styles doesn't achieve the desired result

### ✅ Correct Approach: Work with Existing Styles

```tsx
// Example: Fixing sidebar indentation issues
// Instead of custom absolute positioning, override the component's default margins/padding
<SidebarMenuSub className="mx-0 ml-3.5 px-0 pl-2.5">
	{/* This works with the component's existing structure */}
</SidebarMenuSub>
```

### ❌ Avoid: Custom Solutions First

```tsx
// Instead of immediately jumping to custom absolute positioning:
<SidebarMenuSubItem className="relative">
  <button className="absolute right-1 top-1/2 -translate-y-1/2">
    {/* Custom positioning that fights against component defaults */}
  </button>
</SidebarMenuSubItem>

// First try working with the component's existing styles:
<SidebarMenuSub className="mx-0 ml-3.5 px-0 pl-2.5">
  {/* Much cleaner and more maintainable */}
</SidebarMenuSub>
```

### Why This Matters:

- **Maintainability**: Working with component defaults is more future-proof
- **Consistency**: Maintains the design system's intended behavior
- **Performance**: Avoids complex CSS that fights against existing styles
- **Debugging**: Easier to understand and modify later
- **Component Updates**: Less likely to break when components are updated

### Investigation Steps:

1. **Use browser DevTools** to inspect the component's applied styles
2. **Check the component's source code** to understand its structure
3. **Look for existing className props** that allow style customization
4. **Test with specific margin/padding overrides** before custom solutions
5. **Document the solution** for future reference

# File Organization

## No Barrel Exports - Index Files Are Banned

**IMPORTANT**: Barrel exports via index files (`index.ts`, `index.tsx`, `index.js`, etc.) are banned in this repository.

### ❌ Do Not Create:

- `src/components/ui/index.ts`
- `src/hooks/index.ts`
- `src/utils/index.ts`
- Any `index.*` files in component directories

### ✅ Instead:

- Import directly from specific files: `import { Button } from "./components/ui/button"`
- Export components from their own files: `export { Button } from "./button"`
- Use explicit file paths in imports

### Why Barrel Exports Are Banned:

- Makes imports less explicit and harder to trace
- Creates unnecessary abstraction layers
- Can lead to circular dependency issues
- Makes refactoring and moving files more difficult
- Obscures the actual file structure
- Prevents effective tree-shaking in bundlers

# Naming Conventions

## Props Naming - Critical Distinction

**CRITICAL**: Props naming depends on whether they will be spread onto DOM elements or not.

### Props for DOM Elements (camelCase Required)

**MANDATORY**: Props that will be spread onto DOM elements (`{...props}`) MUST use camelCase to match React/DOM conventions.

```tsx
// ✅ CORRECT: Props that can be spread onto DOM elements
interface Button_Props extends React.ComponentProps<"button"> {
	variant?: "default" | "destructive" | "outline";
	size?: "default" | "sm" | "lg";
	className?: string;
	onClick?: () => void;
	disabled?: boolean;
	children?: React.ReactNode;
}

function Button({ className, variant = "default", size = "default", ...props }: Button_Props) {
	return (
		<button
			className={cn("Button", BUTTON_VARIANTS[variant], BUTTON_SIZES[size], className)}
			{...props} // ✅ Works because props use camelCase
		/>
	);
}
```

### Custom Component Props (camelCase Required)

For props that are specific to your component and will NOT be spread onto DOM elements, use camelCase for consistency:

```tsx
// ✅ CORRECT: Custom component props (not spread onto DOM)
interface SearchFilter_Props {
	searchQuery: string; // Custom prop - camelCase
	onSearchChange: (query: string) => void; // Custom prop - camelCase
	showArchived: boolean; // Custom prop - camelCase
	className?: string; // Will be manually assigned - camelCase
}

function SearchFilter({ searchQuery, onSearchChange, showArchived, className }: SearchFilter_Props) {
	return (
		<div className={cn("SearchFilter", className)}>
			<input
				value={searchQuery}
				onChange={(e) => onSearchChange(e.target.value)} // Used manually, not spread
			/>
		</div>
	);
}
```

### Props Destructuring Pattern

When destructuring props that extend DOM element props, separate the custom props from the spreadable props:

```tsx
interface CustomButton_Props extends React.ComponentProps<"button"> {
	customBehavior?: boolean; // Custom prop - camelCase
	specialMode?: "normal" | "enhanced"; // Custom prop - camelCase
}

function CustomButton({
	customBehavior,
	specialMode,
	className,
	...props // DOM props in camelCase for spreading
}: CustomButton_Props) {
	// Local variables use camelCase
	const enhancedClass = specialMode === "enhanced" ? "CustomButton-enhanced" : "";

	return (
		<button
			className={cn("CustomButton", enhancedClass, className)}
			{...props} // ✅ Safe to spread DOM props
		/>
	);
}
```

## CamelCase for Local Symbols

**MANDATORY**: Use camelCase for ALL local symbols within React components, including:

- State variables and their setters
- Local functions and variables
- Hook parameters and return values
- Internal component identifiers
- Object properties and method parameters

### ✅ Correct Local Symbol Usage:

```tsx
function SearchComponent() {
	const [searchQuery, setSearchQuery] = useState("");
	const [isLoading, setIsLoading] = useState(false);

	const handleSearchChange = useCallback((value: string) => {
		setSearchQuery(value);
	}, []);

	const filteredResults = useMemo(() => {
		return results.filter((item) => item.title.toLowerCase().includes(searchQuery.toLowerCase()));
	}, [results, searchQuery]);

	return (
		<div className="SearchComponent">
			<input value={searchQuery} onChange={(e) => setSearchQuery(e.target.value)} />
		</div>
	);
}
```

### External API Consistency:

When interfacing with external APIs or libraries that use camelCase, keep their naming as-is and use camelCase for your local transformations:

```tsx
function UserProfile() {
	// External API uses camelCase - keep as-is
	const { firstName, lastName } = useUser();

	// Local transformations use camelCase
	const [displayName, setDisplayName] = useState("");
	const [isEditing, setIsEditing] = useState(false);

	const updateDisplayName = useCallback(() => {
		setDisplayName(`${firstName} ${lastName}`);
	}, [firstName, lastName]);
```

## Component Interface Naming

When defining Props interfaces for React components, use the following naming format:

**Format**: `ComponentName_Props`

### ✅ Correct Usage:

```tsx
// For a component named ThemeProvider
export interface ThemeProvider_Props {
	children: ReactNode;
	className?: string; // camelCase for DOM compatibility
	custom_theme?: string; // snake_case for custom prop
}

// For a component named MessageComposer
export interface MessageComposer_Props extends React.ComponentProps<"div"> {
	onSubmit: (message: string) => void; // camelCase - could be spread
	placeholder?: string; // camelCase - standard DOM attribute
	custom_validation?: boolean; // snake_case - custom prop
}
```

# React 19 Context Patterns

## Modern Context with use Hook

**MANDATORY**: Use React 19's `use` hook instead of `useContext` for consuming context.

### Context Setup Pattern:

```tsx
import { createContext, use, useState, ReactNode } from "react";

// Context interface with camelCase for internal state
interface SearchContextType {
	searchQuery: string;
	setSearchQuery: (query: string) => void;
	isLoading: boolean;
	setIsLoading: (loading: boolean) => void;
}

const SearchContext = createContext<SearchContextType | null>(null);

// Custom hook using React 19 'use' hook
const useSearchContext = () => {
	const context = use(SearchContext);
	if (!context) {
		throw new Error("useSearchContext must be used within SearchContextProvider");
	}
	return context;
};

// Provider component with camelCase state
function SearchContextProvider({ children }: { children: ReactNode }) {
	const [searchQuery, setSearchQuery] = useState("");
	const [isLoading, setIsLoading] = useState(false);

	return (
		<SearchContext.Provider
			value={{
				searchQuery,
				setSearchQuery,
				isLoading,
				setIsLoading,
			}}
		>
			{children}
		</SearchContext.Provider>
	);
}
```

# Component Class Name Requirements

## Critical Rule: ALL Classes Must Be Prefixed

**MANDATORY**: ALL CSS classes within a React component MUST be prefixed with the component name. This applies to every single class, not just semantic ones.

### Class Name Format Requirements

#### Root Element

- Use the component name in PascalCase: `ComponentName`
- Example: `Thread`, `MessageComposer`, `UserActionBar`

#### Child Elements

- Format: `ComponentName-description-of-element-and-modifiers`
- Use kebab-case for the description part
- Include relevant state modifiers when applicable

### Implementation Guidelines

1. **ALL classes must be prefixed** - no exceptions for utility or state classes
2. **Use kebab-case for multi-word descriptions** in class names
3. **Combine with Tailwind classes** using the `cn()` utility:

```tsx
<div className={cn("Thread", "bg-background box-border flex h-full")}>
```

4. **State-aware classes must also be prefixed**:

```tsx
<button className={cn(
  "ComposerAction-send-button",
  is_loading && "ComposerAction-send-button-loading",
  "my-2.5 size-8 p-2"
)}>
```

5. **Nested components** maintain their own prefixing:

```tsx
// In Thread component - use Thread prefix
<div className={cn("Thread-composer", "sticky bottom-0")}>
  <Composer />
</div>

// In Composer component - use Composer prefix
<div className={cn("Composer", "focus-within:border-ring/20")}>
  <input className={cn("Composer-input", "placeholder:text-muted-foreground")} />
</div>
```

### Adding Custom Classes

When adding custom classes, use the prefixed naming pattern directly:

**Pattern**: `<ComponentName>-<sub-component-name>-<element-identifier>`

```tsx
// Custom class example
<div
	ref={user_button_ref}
	className={cn(
		"MainAppSidebar-clerk-wrapper", // New custom class with proper prefix
		"absolute sr-only right-[-30px] bottom-0 h-0 w-0"
	)}
>
```

## ❌ Incorrect vs ✅ Correct Class Usage

```tsx
// ❌ WRONG: Mixing prefixed and non-prefixed classes
<div className={cn("Thread", "viewport", "bg-background")}>
  <div className={cn("messages_container", "Thread_header")}>

// ✅ CORRECT: All classes properly prefixed with kebab-case
<div className={cn("Thread", "Thread-viewport", "bg-background")}>
  <div className={cn("Thread-messages-container", "Thread-header")}>
```

# Component Variant and Size Handling

## Direct String Constants Pattern

For components with multiple variants, sizes, or states, define string constants for each variation:

```tsx
// Define variant constants
const BUTTON_VARIANTS = {
	default: "Button-variant-default",
	destructive: "Button-variant-destructive",
	outline: "Button-variant-outline",
	ghost: "Button-variant-ghost",
} as const;

const BUTTON_SIZES = {
	default: "Button-size-default",
	sm: "Button-size-sm",
	lg: "Button-size-lg",
	icon: "Button-size-icon",
} as const;

type Variant = keyof typeof BUTTON_VARIANTS;
type Size = keyof typeof BUTTON_SIZES;

type Button_Props = React.ComponentProps<"button"> & {
	variant?: Variant;
	size?: Size;
};

function Button({ className, variant = "default", size = "default", ...props }: Button_Props) {
	return <button className={cn("Button", BUTTON_VARIANTS[variant], BUTTON_SIZES[size], className)} {...props} />;
}
```

### Null Values for Opt-Out Styling

Allow `null` as a valid value to opt out of variant styling entirely:

```tsx
type Variant = keyof typeof BUTTON_VARIANTS | null;

// Usage in JSX with null check
function Button({ className, variant = "default", size = "default", ...props }: Button_Props) {
	return (
		<button
			className={cn(
				"Button",
				variant && BUTTON_VARIANTS[variant], // Only applies if variant is not null
				size && BUTTON_SIZES[size],
				className,
			)}
			{...props}
		/>
	);
}
```

# Form Component Integration

When using shadcn/ui form components, integrate them with the appropriate naming patterns:

```tsx
import { Checkbox } from "@/components/ui/checkbox";
import { Label } from "@/components/ui/label";

interface ShowArchivedCheckbox_Props {
	checked: boolean;
	onCheckedChange: (checked: boolean) => void; // camelCase - matches Checkbox API
	className?: string; // camelCase - for DOM compatibility
}

function ShowArchivedCheckbox({ checked, onCheckedChange, className }: ShowArchivedCheckbox_Props) {
	const checkboxId = React.useId(); // Local variable - camelCase

	return (
		<div className={cn("mb-4 flex items-center space-x-2", className)}>
			<Checkbox
				id={checkboxId}
				checked={checked}
				onCheckedChange={(checked) => onCheckedChange(checked === true)}
				className={cn("ShowArchivedCheckbox-checkbox")}
			/>
			<Label htmlFor={checkboxId} className={cn("ShowArchivedCheckbox-label", "cursor-pointer")}>
				Show archived
			</Label>
		</div>
	);
}
```

# React Hook Usage Guidelines

## Avoid useEffect When Possible

Minimize the use of `useEffect` to prevent infinite loops, dependency issues, and performance problems. Instead:

1. **Use event handlers** for user interactions and state changes
2. **Use useMemo** for synchronous data transformations
3. **Use useMemo with promises** for async data transformations that depend on other state

## Use Refs for Non-Reactive State

Use `useRef` instead of `useState` for values that don't need to trigger re-renders:

### ❌ Avoid: useState for non-reactive values

```tsx
const [isProcessing, setIsProcessing] = useState(false);
// These state changes cause unnecessary re-renders
```

### ✅ Prefer: useRef for non-reactive values

```tsx
const isProcessingRef = useRef(false);
const cacheRef = useRef(new Map());

// No re-renders triggered
const handleProcess = async () => {
	isProcessingRef.current = true; // No re-render
	await processData();
	isProcessingRef.current = false; // No re-render
};
```

### When to Use Refs vs State

**Use `useRef` when:**

- Value is used for internal component logic only
- Value doesn't affect UI rendering
- Value is used to prevent operations (like blocking duplicate API calls)
- Value is used for caching or memoization

**Use `useState` when:**

- Value affects what's rendered in the UI
- Value is used in JSX conditionals or expressions
- Value needs to trigger re-renders when changed

## Preferred Patterns

### ✅ Prefer: useMemo for sync transformations

```tsx
const [data, setData] = useState(null);

const transformedData = useMemo(() => {
	return data ? processData(data) : null;
}, [data]);
```

### ✅ Prefer: Event handlers for user interactions

```tsx
const handleToggle = useCallback(async (newValue: boolean) => {
	if (newValue) {
		const result = await processToggle();
		setProcessedResult(result);
	}
	setToggleState(newValue);
}, []);

<button onClick={() => handleToggle(!toggleState)}>Toggle</button>;
```

## Guidelines Summary

- **Event handlers**: Use for user interactions, form submissions, button clicks
- **useMemo**: Use for synchronous data transformations and computations
- **useMemo + promises**: Use for async operations that depend on state changes
- **useRef**: Use for non-reactive values that don't affect UI rendering
- **useState**: Use only for values that need to trigger re-renders
- **useEffect**: Only use when you genuinely need to sync with external systems (DOM, timers, subscriptions)

## Benefits

- **Easy debugging**: Quickly identify components in browser DevTools
- **Better testing**: Reliable selectors for test automation
- **Component tracking**: Understand component hierarchy in production
- **Design system consistency**: Clear component boundaries and relationships
- **Performance**: Avoid unnecessary re-renders and infinite loops from useEffect
- **Maintainability**: Clearer data flow and fewer side effects
- **Optimization**: Use refs to prevent unnecessary re-renders for internal state
- **Modern React patterns**: Leverage React 19 features like the `use` hook
- **Consistent naming**: Root-level exports use snake_case for namespacing, local variables use camelCase for consistency with modern JavaScript conventions
