---
description: Guidelines for creating and styling React components, including class naming patterns, semantic classnames, and component organization
globs: packages/**/src/components/**/*.tsx
alwaysApply: false
---

React Components Guidelines

# File Organization

## No Barrel Exports - Index Files Are Banned

**IMPORTANT**: Barrel exports via index files (`index.ts`, `index.tsx`, `index.js`, etc.) are banned in this repository.

### ❌ Do Not Create:

- `src/components/ui/index.ts`
- `src/hooks/index.ts`
- `src/utils/index.ts`
- Any `index.*` files in component directories

### ✅ Instead:

- Import directly from specific files: `import { Button } from "./components/ui/button"`
- Export components from their own files: `export { Button } from "./button"`
- Use explicit file paths in imports

### Why Barrel Exports Are Banned:

- Makes imports less explicit and harder to trace
- Creates unnecessary abstraction layers
- Can lead to circular dependency issues
- Makes refactoring and moving files more difficult
- Obscures the actual file structure
- Prevents effective tree-shaking in bundlers
- Creates "barrel export" anti-pattern

### Fixing Existing Barrel Exports:

1. Remove the barrel export (index file)
2. Update all imports to point directly to the component files
3. Example: Change `from "../components/canvas"` to `from "../components/canvas/canvas"`

# Component Interface Naming

## Props Interface Convention

When defining Props interfaces for React components, use the following naming format:

**Format**: `ComponentName_Props`

### ✅ Correct Usage:

```tsx
// For a component named ThemeProvider
export interface ThemeProvider_Props {
	children: ReactNode;
	className?: string;
}

// For a component named MessageComposer
export interface MessageComposer_Props {
	onSubmit: (message: string) => void;
	placeholder?: string;
	disabled?: boolean;
}

// For a component named UserActionBar
export interface UserActionBar_Props {
	user: User;
	actions: Action[];
	variant?: "default" | "compact";
}
```

### Benefits:

- **Consistent naming**: All Props interfaces follow the same pattern
- **Easy identification**: Immediately clear which component the props belong to
- **IDE autocompletion**: Better grouping in IDE suggestions with underscore syntax

# Semantic Classname Convention

## Overview

Always add semantic classnames to all elements in React components to make them easily identifiable when inspecting live HTML. This helps with debugging, testing, and component identification.

## Classname Format

### Root Element

- Use the component name in PascalCase: `ComponentName`
- Example: `Thread`, `MessageComposer`, `UserActionBar`

### Child Elements

- Format: `ComponentName-description-of-element-and-modifiers`
- Use kebab-case for the description part
- Include relevant state modifiers when applicable
- Examples:
  - `Thread-viewport`
  - `Thread-messages-container`
  - `MessageComposer-input`
  - `MessageComposer-send-button`
  - `UserActionBar-edit-button`
  - `BranchPicker-button-active`
  - `AssistantMessage-content-loading`

## Implementation Guidelines

1. **Always add semantic classnames** in addition to existing styling classes (Tailwind, etc.)
2. **Combine with existing classes** using the `cn()` utility:

   ```tsx
   <div className={cn("Thread", "bg-background box-border flex h-full")}>
   ```

3. **Use state-aware classnames** for dynamic elements:

   ```tsx
   <button className={cn(
     "ComposerAction-send-button",
     isLoading && "ComposerAction-send-button-loading",
     "my-2.5 size-8 p-2"
   )}>
   ```

4. **Nested components** should include their parent context:

   ```tsx
   // In Thread component
   <div className={cn("Thread-composer", "sticky bottom-0")}>
     <Composer />
   </div>

   // In Composer component
   <div className={cn("Composer", "focus-within:border-ring/20")}>
     <input className={cn("Composer-input", "placeholder:text-muted-foreground")} />
   </div>
   ```

# Component Class Name Organization

## Class Names Object Pattern

For components with multiple variants, sizes, or states, organize class names in a structured object using the following pattern:

### Basic Structure

```tsx
const ComponentName_classNames = {
	root: "ComponentName",
	variants: {
		variant: {
			default: "ComponentName-variant-default",
			primary: "ComponentName-variant-primary",
			secondary: "ComponentName-variant-secondary",
		},
		size: {
			sm: "ComponentName-size-sm",
			default: "ComponentName-size-default",
			lg: "ComponentName-size-lg",
		},
	},
	defaultVariants: {
		variant: "default",
		size: "default",
	},
};
```

### Null Values for Opt-Out Styling

For components that need the ability to opt out of variant or size styling entirely, allow `null` as a valid value:

```tsx
type Variant = keyof typeof ComponentName_classNames.variants.variant | null;
type Size = keyof typeof ComponentName_classNames.variants.size | null;

type ComponentName_Props = React.ComponentProps<"button"> & {
	variant?: Variant; // Can be a variant key or null
	size?: Size; // Can be a size key or null
	asChild?: boolean;
};
```

**When `null` is passed:**

- No variant/size-specific classes are applied
- Only the root class and any custom className are applied
- Useful for completely custom styling or when inheriting styles from parent components

**Usage in JSX:**

```tsx
function ComponentName({ className, variant, size, ...props }: ComponentName_Props) {
	return (
		<button
			className={cn(
				ComponentName_classNames.root,
				variant && ComponentName_classNames.variants.variant[variant], // Only applies if variant is not null
				size && ComponentName_classNames.variants.size[size], // Only applies if size is not null
				className,
			)}
			{...props}
		/>
	);
}
```

**Example usage:**

```tsx
// Uses default variant and size
<Button>Click me</Button>

// Uses specific variant and size
<Button variant="primary" size="lg">Click me</Button>

// Opts out of variant styling, keeps size
<Button variant={null} size="lg">Custom styled</Button>

// Opts out of both variant and size styling
<Button variant={null} size={null}>Completely custom</Button>
```

### CSS Integration

This pattern works seamlessly with our CSS guidelines from `airule-code-css.mdc`:

- **CSS classes** use the same naming: `.Button-variant-default`, `.Button-size-lg`
- **CSS file** should be imported: `import "./component-name.css"`
- **Low specificity** maintained with `:where()` selectors in CSS

### TypeScript Integration

Create proper TypeScript types that reference the class names object:

```tsx
type Variant = keyof typeof ComponentName_classNames.variants.variant;
type Size = keyof typeof ComponentName_classNames.variants.size;

type ComponentName_Props = React.ComponentProps<"button"> & {
	variant?: Variant;
	size?: Size;
	asChild?: boolean;
};
```

### Usage in JSX

Apply the class names using the `cn()` utility:

```tsx
function ComponentName({ className, variant, size, ...props }: ComponentName_Props) {
	return (
		<button
			className={cn(
				ComponentName_classNames.root,
				variant && ComponentName_classNames.variants.variant[variant],
				size && ComponentName_classNames.variants.size[size],
				className,
			)}
			{...props}
		/>
	);
}
```

### Exporting Class Names

Export the class names object if it needs to be used externally:

```tsx
export { ComponentName, ComponentName_classNames };

// Alternative naming for backward compatibility
export { ComponentName_classNames as componentNameVariants };
```

### Complete Example

```tsx
import * as React from "react";
import { cn } from "@/lib/utils";
import "./button.css";

const Button_class_names = {
	root: "Button",
	variants: {
		variant: {
			default: "Button-variant-default",
			destructive: "Button-variant-destructive",
			outline: "Button-variant-outline",
			secondary: "Button-variant-secondary",
			ghost: "Button-variant-ghost",
			link: "Button-variant-link",
		},
		size: {
			default: "Button-size-default",
			sm: "Button-size-sm",
			lg: "Button-size-lg",
			icon: "Button-size-icon",
		},
	},
	defaultVariants: {
		variant: "default",
		size: "default",
	},
};

type Variant = keyof typeof Button_class_names.variants.variant;
type Size = keyof typeof Button_class_names.variants.size;

type Button_Props = React.ComponentProps<"button"> & {
	variant?: Variant;
	size?: Size;
	asChild?: boolean;
};

function Button({ className, variant, size, asChild = false, ...props }: Button_Props) {
	const Comp = asChild ? Slot : "button";

	return (
		<Comp
			className={cn(
				Button_class_names.root,
				variant && Button_class_names.variants.variant[variant],
				size && Button_class_names.variants.size[size],
				className,
			)}
			{...props}
		/>
	);
}

export { Button, Button_class_names as buttonVariants };
```

### Benefits of This Pattern

- **Type Safety**: TypeScript ensures only valid variants are used
- **Maintainability**: All class names centralized in one object
- **Consistency**: Matches CSS naming conventions exactly
- **Flexibility**: Easy to add new variants or modify existing ones
- **Debugging**: Clear mapping between props and CSS classes
- **Reusability**: Class names object can be exported and reused

### When to Use This Pattern

**Use this pattern when:**

- Component has multiple variants (design variations)
- Component has multiple sizes
- Component has complex state-based styling
- You need to export class names for external use

**Use simple semantic classes when:**

- Component has no variants or sizes
- Component is simple with minimal styling variations
- Component is a leaf component with no complex state

# React Hook Usage Guidelines

## Avoid useEffect When Possible

Minimize the use of `useEffect` to prevent infinite loops, dependency issues, and performance problems. Instead:

1. **Use event handlers** for user interactions and state changes
2. **Use useMemo** for synchronous data transformations
3. **Use useMemo with promises** for async data transformations that depend on other state

## Use Refs for Non-Reactive State

Use `useRef` instead of `useState` for values that don't need to trigger re-renders or be reactive dependencies:

### ❌ Avoid: useState for non-reactive values

```tsx
const [isProcessing, setIsProcessing] = useState(false);
const [cache, setCache] = useState(new Map());

// These state changes cause unnecessary re-renders
const handleProcess = async () => {
	setIsProcessing(true); // Triggers re-render
	await processData();
	setIsProcessing(false); // Triggers re-render
};
```

### ✅ Prefer: useRef for non-reactive values

```tsx
const isProcessingRef = useRef(false);
const cacheRef = useRef(new Map());

// No re-renders triggered
const handleProcess = async () => {
	isProcessingRef.current = true; // No re-render
	await processData();
	isProcessingRef.current = false; // No re-render
};
```

### When to Use Refs vs State

**Use `useRef` when:**

- Value is used for internal component logic only
- Value doesn't affect UI rendering
- Value is used to prevent operations (like blocking duplicate API calls)
- Value is used for caching or memoization
- Value is used for tracking component lifecycle states

**Use `useState` when:**

- Value affects what's rendered in the UI
- Value is used in JSX conditionals or expressions
- Value needs to trigger re-renders when changed
- Value is used as a dependency in useEffect or useMemo

### Examples

```tsx
// ✅ Good: Using refs for non-reactive state
const MyComponent = () => {
	const [count, setCount] = useState(0); // UI state - needs re-renders
	const [isVisible, setIsVisible] = useState(true); // UI state - affects rendering

	const isLoadingRef = useRef(false); // Internal state - no re-render needed
	const abortControllerRef = useRef<AbortController | null>(null); // Cleanup reference
	const cacheRef = useRef(new Map()); // Performance optimization

	const handleFetch = async () => {
		if (isLoadingRef.current) return; // Prevent duplicate calls

		isLoadingRef.current = true;
		abortControllerRef.current = new AbortController();

		try {
			const data = await fetchData(abortControllerRef.current.signal);
			cacheRef.current.set("data", data);
		} finally {
			isLoadingRef.current = false;
			abortControllerRef.current = null;
		}
	};

	return (
		<div>
			{isVisible && <div>Count: {count}</div>}
			<button onClick={() => setCount((c) => c + 1)}>Increment</button>
			<button onClick={handleFetch}>Fetch Data</button>
		</div>
	);
};
```

## Preferred Patterns

### ❌ Avoid: useEffect for data transformation

```tsx
const [data, setData] = useState(null);
const [transformedData, setTransformedData] = useState(null);

useEffect(() => {
	if (data) {
		setTransformedData(processData(data));
	}
}, [data]);
```

### ✅ Prefer: useMemo for sync transformations

```tsx
const [data, setData] = useState(null);

const transformedData = useMemo(() => {
	return data ? processData(data) : null;
}, [data]);
```

### ❌ Avoid: useEffect for async operations

```tsx
const [content, setContent] = useState("");
const [parsedContent, setParsedContent] = useState(null);

useEffect(() => {
	if (content) {
		parseContentAsync(content).then(setParsedContent);
	}
}, [content]);
```

### ✅ Prefer: useMemo with promises for async transformations

```tsx
const [content, setContent] = useState("");

const parsedContentPromise = useMemo(() => {
	return content ? parseContentAsync(content) : null;
}, [content]);

// Execute the promise when needed
useMemo(() => {
	if (parsedContentPromise) {
		parsedContentPromise.then(setParsedContent).catch(console.error);
	}
}, [parsedContentPromise]);
```

### ✅ Prefer: Event handlers for user interactions

```tsx
// Instead of useEffect watching state changes
const handleToggle = useCallback(async (newValue: boolean) => {
	if (newValue) {
		const result = await processToggle();
		setProcessedResult(result);
	}
	setToggleState(newValue);
}, []);

<button onClick={() => handleToggle(!toggleState)}>Toggle</button>;
```

## Guidelines Summary

- **Event handlers**: Use for user interactions, form submissions, button clicks
- **useMemo**: Use for synchronous data transformations and computations
- **useMemo + promises**: Use for async operations that depend on state changes
- **useRef**: Use for non-reactive values that don't affect UI rendering
- **useState**: Use only for values that need to trigger re-renders
- **useEffect**: Only use when you genuinely need to sync with external systems (DOM, timers, subscriptions)

## Examples

### Component with multiple states:

```tsx
const MessageStatus = ({ status }: { status: "pending" | "sent" | "error" }) => {
	return (
		<div className={cn("MessageStatus", `MessageStatus-${status}`, "flex items-center gap-2")}>
			<Icon className={cn("MessageStatus-icon", `MessageStatus-icon-${status}`)} />
			<span className={cn("MessageStatus-text")}>Status: {status}</span>
		</div>
	);
};
```

### List component:

```tsx
const ThreadList = ({ threads }: { threads: Thread[] }) => {
	return (
		<div className={cn("ThreadList", "space-y-2")}>
			{threads.map((thread) => (
				<div
					key={thread.id}
					className={cn("ThreadList-item", thread.isActive && "ThreadList-item-active", "p-3 rounded-lg border")}
				>
					<h3 className={cn("ThreadList-item-title", "font-semibold")}>{thread.title}</h3>
				</div>
			))}
		</div>
	);
};
```

## Benefits

- **Easy debugging**: Quickly identify components in browser DevTools
- **Better testing**: Reliable selectors for test automation
- **Component tracking**: Understand component hierarchy in production
- **Design system consistency**: Clear component boundaries and relationships
- **Performance**: Avoid unnecessary re-renders and infinite loops from useEffect
- **Maintainability**: Clearer data flow and fewer side effects
- **Optimization**: Use refs to prevent unnecessary re-renders for internal state
