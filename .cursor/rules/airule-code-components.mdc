---
description: Guidelines for creating and styling React components, including class naming patterns, semantic classnames, and component organization
globs: packages/**/src/components/**/*.tsx
alwaysApply: false
---

React Components Guidelines

# File Organization

## No Barrel Exports - Index Files Are Banned

**IMPORTANT**: Barrel exports via index files (`index.ts`, `index.tsx`, `index.js`, etc.) are banned in this repository.

### ❌ Do Not Create:

- `src/components/ui/index.ts`
- `src/hooks/index.ts`
- `src/utils/index.ts`
- Any `index.*` files in component directories

### ✅ Instead:

- Import directly from specific files: `import { Button } from "./components/ui/button"`
- Export components from their own files: `export { Button } from "./button"`
- Use explicit file paths in imports

### Why Barrel Exports Are Banned:

- Makes imports less explicit and harder to trace
- Creates unnecessary abstraction layers
- Can lead to circular dependency issues
- Makes refactoring and moving files more difficult
- Obscures the actual file structure
- Prevents effective tree-shaking in bundlers
- Creates "barrel export" anti-pattern

### Fixing Existing Barrel Exports:

1. Remove the barrel export (index file)
2. Update all imports to point directly to the component files
3. Example: Change `from "../components/canvas"` to `from "../components/canvas/canvas"`

# Component Interface Naming

## Props Interface Convention

When defining Props interfaces for React components, use the following naming format:

**Format**: `ComponentName_Props`

### ✅ Correct Usage:

```tsx
// For a component named ThemeProvider
export interface ThemeProvider_Props {
	children: ReactNode;
	className?: string;
}

// For a component named MessageComposer
export interface MessageComposer_Props {
	onSubmit: (message: string) => void;
	placeholder?: string;
	disabled?: boolean;
}

// For a component named UserActionBar
export interface UserActionBar_Props {
	user: User;
	actions: Action[];
	variant?: "default" | "compact";
}
```

### Benefits:

- **Consistent naming**: All Props interfaces follow the same pattern
- **Easy identification**: Immediately clear which component the props belong to
- **IDE autocompletion**: Better grouping in IDE suggestions with underscore syntax

# Component Class Name Requirements

## Critical Rule: ALL Classes Must Be Prefixed

**MANDATORY**: ALL CSS classes within a React component MUST be prefixed with the component name. This applies to every single class, not just semantic ones.

### Why This Rule Exists

- **Component Isolation**: Prevents style conflicts between components
- **Debugging Clarity**: Instantly identify which component a class belongs to in DevTools
- **Maintainability**: Makes refactoring and component organization much easier
- **Testing Reliability**: Provides stable selectors for testing that won't conflict

### Class Name Format Requirements

#### Root Element

- Use the component name in PascalCase: `ComponentName`
- Example: `Thread`, `MessageComposer`, `UserActionBar`

#### Child Elements

- Format: `ComponentName_description_of_element_and_modifiers`
- Use snake_case for the description part
- Include relevant state modifiers when applicable
- Examples:
  - `Thread_viewport`
  - `Thread_messages_container`
  - `MessageComposer_input`
  - `MessageComposer_send_button`
  - `UserActionBar_edit_button`
  - `BranchPicker_button_active`
  - `AssistantMessage_content_loading`

## Implementation Guidelines

1. **ALL classes must be prefixed** - no exceptions for utility or state classes
2. **Combine with existing styling** using the `cn()` utility:

   ```tsx
   <div className={cn("Thread", "bg-background box-border flex h-full")}>
   ```

3. **State-aware classes must also be prefixed**:

   ```tsx
   <button className={cn(
     "ComposerAction_send_button",
     isLoading && "ComposerAction_send_button_loading",
     "my-2.5 size-8 p-2"
   )}>
   ```

4. **Nested components** maintain their own prefixing:

   ```tsx
   // In Thread component - use Thread prefix
   <div className={cn("Thread_composer", "sticky bottom-0")}>
     <Composer />
   </div>

   // In Composer component - use Composer prefix
   <div className={cn("Composer", "focus-within:border-ring/20")}>
     <input className={cn("Composer_input", "placeholder:text-muted-foreground")} />
   </div>
   ```

## ❌ Incorrect Class Usage

```tsx
// WRONG: Mixing prefixed and non-prefixed classes
<div className={cn("Thread", "viewport", "bg-background")}>
  <div className={cn("messages_container", "Thread_header")}>
    <button className={cn("send_btn", "Thread_send_button_active")}>
```

## ✅ Correct Class Usage

```tsx
// CORRECT: All classes properly prefixed
<div className={cn("Thread", "Thread_viewport", "bg-background")}>
  <div className={cn("Thread_messages_container", "Thread_header")}>
    <button className={cn("Thread_send_btn", "Thread_send_button_active")}>
```

# Component Class Name Organization

## Class Names Object Pattern

For components with multiple variants, sizes, or states, organize class names in a structured object using the following pattern.

### Naming Requirements

1. **Object Name**: Use `ComponentName_class_names` (with underscore and snake_case)
2. **Object Properties**: Use snake_case for all property names
3. **Class Values**: Must be prefixed with ComponentName as established above

### Basic Structure

```tsx
const ComponentName_class_names = {
	root: "ComponentName",
	variants: {
		variant: {
			default: "ComponentName_variant_default",
			primary: "ComponentName_variant_primary",
			secondary: "ComponentName_variant_secondary",
		},
		size: {
			sm: "ComponentName_size_sm",
			default: "ComponentName_size_default",
			lg: "ComponentName_size_lg",
		},
	},
	default_variants: {
		variant: "default",
		size: "default",
	},
};
```

### Snake Case Property Examples

```tsx
const MainAppSidebar_class_names = {
	root: "MainAppSidebar",
	app_logo_container: "MainAppSidebar_app_logo_container",
	app_link: "MainAppSidebar_app_link",
	navigation: {
		home: "MainAppSidebar_nav_home",
		chat: "MainAppSidebar_nav_chat",
	},
	profile: {
		section: "MainAppSidebar_profile_section",
		user_section: "MainAppSidebar_user_section",
	},
	user_profile: {
		button: "MainAppSidebar_user_profile_button",
		avatar: "MainAppSidebar_user_profile_avatar",
		info: "MainAppSidebar_user_profile_info",
		name: "MainAppSidebar_user_profile_name",
		email: "MainAppSidebar_user_profile_email",
	},
};
```

### Null Values for Opt-Out Styling

For components that need the ability to opt out of variant or size styling entirely, allow `null` as a valid value:

```tsx
type Variant = keyof typeof ComponentName_class_names.variants.variant | null;
type Size = keyof typeof ComponentName_class_names.variants.size | null;

type ComponentName_Props = React.ComponentProps<"button"> & {
	variant?: Variant; // Can be a variant key or null
	size?: Size; // Can be a size key or null
	asChild?: boolean;
};
```

**When `null` is passed:**

- No variant/size-specific classes are applied
- Only the root class and any custom className are applied
- Useful for completely custom styling or when inheriting styles from parent components

**Usage in JSX:**

```tsx
function ComponentName({ className, variant, size, ...props }: ComponentName_Props) {
	return (
		<button
			className={cn(
				ComponentName_class_names.root,
				variant && ComponentName_class_names.variants.variant[variant], // Only applies if variant is not null
				size && ComponentName_class_names.variants.size[size], // Only applies if size is not null
				className,
			)}
			{...props}
		/>
	);
}
```

**Example usage:**

```tsx
// Uses default variant and size
<Button>Click me</Button>

// Uses specific variant and size
<Button variant="primary" size="lg">Click me</Button>

// Opts out of variant styling, keeps size
<Button variant={null} size="lg">Custom styled</Button>

// Opts out of both variant and size styling
<Button variant={null} size={null}>Completely custom</Button>
```

### CSS Integration

This pattern works seamlessly with our CSS guidelines from `airule-code-css.mdc`:

- **CSS classes** use the same naming: `.Button_variant_default`, `.Button_size_lg`
- **CSS file** should be imported: `import "./component-name.css"`
- **Low specificity** maintained with `:where()` selectors in CSS

### TypeScript Integration

Create proper TypeScript types that reference the class names object:

```tsx
type Variant = keyof typeof ComponentName_class_names.variants.variant;
type Size = keyof typeof ComponentName_class_names.variants.size;

type ComponentName_Props = React.ComponentProps<"button"> & {
	variant?: Variant;
	size?: Size;
	asChild?: boolean;
};
```

### Usage in JSX

Apply the class names using the `cn()` utility:

```tsx
function ComponentName({ className, variant, size, ...props }: ComponentName_Props) {
	return (
		<button
			className={cn(
				ComponentName_class_names.root,
				variant && ComponentName_class_names.variants.variant[variant],
				size && ComponentName_class_names.variants.size[size],
				className,
			)}
			{...props}
		/>
	);
}
```

### Exporting Class Names

Export the class names object if it needs to be used externally:

```tsx
export { ComponentName, ComponentName_class_names };

// Alternative naming for backward compatibility
export { ComponentName_class_names as componentNameVariants };
```

### Complete Example

```tsx
import * as React from "react";
import { cn } from "@/lib/utils";
import "./button.css";

const Button_class_names = {
	root: "Button",
	variants: {
		variant: {
			default: "Button_variant_default",
			destructive: "Button_variant_destructive",
			outline: "Button_variant_outline",
			secondary: "Button_variant_secondary",
			ghost: "Button_variant_ghost",
			link: "Button_variant_link",
		},
		size: {
			default: "Button_size_default",
			sm: "Button_size_sm",
			lg: "Button_size_lg",
			icon: "Button_size_icon",
		},
	},
	default_variants: {
		variant: "default",
		size: "default",
	},
};

type Variant = keyof typeof Button_class_names.variants.variant;
type Size = keyof typeof Button_class_names.variants.size;

type Button_Props = React.ComponentProps<"button"> & {
	variant?: Variant;
	size?: Size;
	asChild?: boolean;
};

function Button({ className, variant, size, asChild = false, ...props }: Button_Props) {
	const Comp = asChild ? Slot : "button";

	return (
		<Comp
			className={cn(
				Button_class_names.root,
				variant && Button_class_names.variants.variant[variant],
				size && Button_class_names.variants.size[size],
				className,
			)}
			{...props}
		/>
	);
}

export { Button, Button_class_names as buttonVariants };
```

### Benefits of This Pattern

- **Type Safety**: TypeScript ensures only valid variants are used
- **Maintainability**: All class names centralized in one object
- **Consistency**: Matches CSS naming conventions exactly
- **Flexibility**: Easy to add new variants or modify existing ones
- **Debugging**: Clear mapping between props and CSS classes
- **Reusability**: Class names object can be exported and reused

### When to Use This Pattern

**Use this pattern when:**

- Component has multiple variants (design variations)
- Component has multiple sizes
- Component has complex state-based styling
- You need to export class names for external use

**Use simple semantic classes when:**

- Component has no variants or sizes
- Component is simple with minimal styling variations
- Component is a leaf component with no complex state

# Adding Custom Classes to Components

## Custom Class Naming Pattern

When a user requests to add a custom class to a component, you must add it to the existing `class_names` object following the established naming conventions.

### Class Name Format

**Pattern**: `<ComponentName>_<sub-component-name>_<element-identifier>`

### Property Name Format

**Pattern**: Use `snake_case` for all property names in the class_names object

### Examples

```tsx
const MainAppSidebar_class_names = {
	root: "MainAppSidebar",
	app_logo_container: "MainAppSidebar_app_logo_container",
	// If user asks for a custom class for a wrapper element:
	clerck_wrapper: "MainAppSidebar_clerck_wrapper",
	user_profile: {
		button: "MainAppSidebar_user_profile_button",
		// If user asks for a custom class for a modal trigger:
		modal_trigger: "MainAppSidebar_user_profile_modal_trigger",
	},
	navigation: {
		home: "MainAppSidebar_nav_home",
		// If user asks for a custom class for navigation icons:
		nav_icon: "MainAppSidebar_nav_icon",
	},
};
```

### Implementation Steps

1. **Identify the location**: Determine where in the class_names object the new property should be added
2. **Follow naming pattern**: Use the ComponentName prefix and descriptive identifier
3. **Use snake_case**: Property names must be in snake_case format
4. **Apply in JSX**: Use the new class name in the component's JSX

### Example Implementation

```tsx
// User requests: "Add a custom class to userButtonRef called clerck_wrapper"

// Step 1: Add to class_names object
const MainAppSidebar_class_names = {
	root: "MainAppSidebar",
	// ... other properties
	clerck_wrapper: "MainAppSidebar_clerck_wrapper", // New custom class
};

// Step 2: Apply in JSX
<div
	ref={userButtonRef}
	className={cn(
		MainAppSidebar_class_names.clerck_wrapper, // Use the new class
		"absolute sr-only right-[-30px] bottom-0 h-0 w-0"
	)}
>
```

### Nested Sub-Components

For nested elements, follow the hierarchical structure:

```tsx
const ComponentName_class_names = {
	root: "ComponentName",
	sub_component: {
		root: "ComponentName_sub_component",
		custom_element: "ComponentName_sub_component_custom_element",
	},
	// Top-level custom classes
	custom_wrapper: "ComponentName_custom_wrapper",
};
```

### Benefits

- **Consistency**: Maintains the established naming pattern
- **Organization**: Keeps all class names centralized and structured
- **Maintainability**: Easy to find and modify class names
- **Type Safety**: TypeScript can validate class name usage
- **Debugging**: Clear mapping between requests and implementation

# React Hook Usage Guidelines

## Avoid useEffect When Possible

Minimize the use of `useEffect` to prevent infinite loops, dependency issues, and performance problems. Instead:

1. **Use event handlers** for user interactions and state changes
2. **Use useMemo** for synchronous data transformations
3. **Use useMemo with promises** for async data transformations that depend on other state

## Use Refs for Non-Reactive State

Use `useRef` instead of `useState` for values that don't need to trigger re-renders or be reactive dependencies:

### ❌ Avoid: useState for non-reactive values

```tsx
const [isProcessing, setIsProcessing] = useState(false);
const [cache, setCache] = useState(new Map());

// These state changes cause unnecessary re-renders
const handleProcess = async () => {
	setIsProcessing(true); // Triggers re-render
	await processData();
	setIsProcessing(false); // Triggers re-render
};
```

### ✅ Prefer: useRef for non-reactive values

```tsx
const isProcessingRef = useRef(false);
const cacheRef = useRef(new Map());

// No re-renders triggered
const handleProcess = async () => {
	isProcessingRef.current = true; // No re-render
	await processData();
	isProcessingRef.current = false; // No re-render
};
```

### When to Use Refs vs State

**Use `useRef` when:**

- Value is used for internal component logic only
- Value doesn't affect UI rendering
- Value is used to prevent operations (like blocking duplicate API calls)
- Value is used for caching or memoization
- Value is used for tracking component lifecycle states

**Use `useState` when:**

- Value affects what's rendered in the UI
- Value is used in JSX conditionals or expressions
- Value needs to trigger re-renders when changed
- Value is used as a dependency in useEffect or useMemo

### Examples

```tsx
// ✅ Good: Using refs for non-reactive state
const MyComponent = () => {
	const [count, setCount] = useState(0); // UI state - needs re-renders
	const [isVisible, setIsVisible] = useState(true); // UI state - affects rendering

	const isLoadingRef = useRef(false); // Internal state - no re-render needed
	const abortControllerRef = useRef<AbortController | null>(null); // Cleanup reference
	const cacheRef = useRef(new Map()); // Performance optimization

	const handleFetch = async () => {
		if (isLoadingRef.current) return; // Prevent duplicate calls

		isLoadingRef.current = true;
		abortControllerRef.current = new AbortController();

		try {
			const data = await fetchData(abortControllerRef.current.signal);
			cacheRef.current.set("data", data);
		} finally {
			isLoadingRef.current = false;
			abortControllerRef.current = null;
		}
	};

	return (
		<div>
			{isVisible && <div>Count: {count}</div>}
			<button onClick={() => setCount((c) => c + 1)}>Increment</button>
			<button onClick={handleFetch}>Fetch Data</button>
		</div>
	);
};
```

## Preferred Patterns

### ❌ Avoid: useEffect for data transformation

```tsx
const [data, setData] = useState(null);
const [transformedData, setTransformedData] = useState(null);

useEffect(() => {
	if (data) {
		setTransformedData(processData(data));
	}
}, [data]);
```

### ✅ Prefer: useMemo for sync transformations

```tsx
const [data, setData] = useState(null);

const transformedData = useMemo(() => {
	return data ? processData(data) : null;
}, [data]);
```

### ❌ Avoid: useEffect for async operations

```tsx
const [content, setContent] = useState("");
const [parsedContent, setParsedContent] = useState(null);

useEffect(() => {
	if (content) {
		parseContentAsync(content).then(setParsedContent);
	}
}, [content]);
```

### ✅ Prefer: useMemo with promises for async transformations

```tsx
const [content, setContent] = useState("");

const parsedContentPromise = useMemo(() => {
	return content ? parseContentAsync(content) : null;
}, [content]);

// Execute the promise when needed
useMemo(() => {
	if (parsedContentPromise) {
		parsedContentPromise.then(setParsedContent).catch(console.error);
	}
}, [parsedContentPromise]);
```

### ✅ Prefer: Event handlers for user interactions

```tsx
// Instead of useEffect watching state changes
const handleToggle = useCallback(async (newValue: boolean) => {
	if (newValue) {
		const result = await processToggle();
		setProcessedResult(result);
	}
	setToggleState(newValue);
}, []);

<button onClick={() => handleToggle(!toggleState)}>Toggle</button>;
```

## Guidelines Summary

- **Event handlers**: Use for user interactions, form submissions, button clicks
- **useMemo**: Use for synchronous data transformations and computations
- **useMemo + promises**: Use for async operations that depend on state changes
- **useRef**: Use for non-reactive values that don't affect UI rendering
- **useState**: Use only for values that need to trigger re-renders
- **useEffect**: Only use when you genuinely need to sync with external systems (DOM, timers, subscriptions)

## Examples

### Component with multiple states:

```tsx
const MessageStatus = ({ status }: { status: "pending" | "sent" | "error" }) => {
	return (
		<div className={cn("MessageStatus", `MessageStatus_${status}`, "flex items-center gap-2")}>
			<Icon className={cn("MessageStatus_icon", `MessageStatus_icon_${status}`)} />
			<span className={cn("MessageStatus_text")}>Status: {status}</span>
		</div>
	);
};
```

### List component:

```tsx
const ThreadList = ({ threads }: { threads: Thread[] }) => {
	return (
		<div className={cn("ThreadList", "space-y-2")}>
			{threads.map((thread) => (
				<div
					key={thread.id}
					className={cn("ThreadList_item", thread.isActive && "ThreadList_item_active", "p-3 rounded-lg border")}
				>
					<h3 className={cn("ThreadList_item_title", "font-semibold")}>{thread.title}</h3>
				</div>
			))}
		</div>
	);
};
```

## Benefits

- **Easy debugging**: Quickly identify components in browser DevTools
- **Better testing**: Reliable selectors for test automation
- **Component tracking**: Understand component hierarchy in production
- **Design system consistency**: Clear component boundaries and relationships
- **Performance**: Avoid unnecessary re-renders and infinite loops from useEffect
- **Maintainability**: Clearer data flow and fewer side effects
- **Optimization**: Use refs to prevent unnecessary re-renders for internal state
