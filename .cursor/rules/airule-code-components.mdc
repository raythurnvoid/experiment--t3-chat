---
description: Guidelines for creating and styling React components, including class naming patterns, semantic classnames, and component organization
globs: packages/**/src/components/**/*.tsx
alwaysApply: false
---

React Components Guidelines

# File Organization

## No Barrel Exports - Index Files Are Banned

**IMPORTANT**: Barrel exports via index files (`index.ts`, `index.tsx`, `index.js`, etc.) are banned in this repository.

### ❌ Do Not Create:

- `src/components/ui/index.ts`
- `src/hooks/index.ts`
- `src/utils/index.ts`
- Any `index.*` files in component directories

### ✅ Instead:

- Import directly from specific files: `import { Button } from "./components/ui/button"`
- Export components from their own files: `export { Button } from "./button"`
- Use explicit file paths in imports

### Why Barrel Exports Are Banned:

- Makes imports less explicit and harder to trace
- Creates unnecessary abstraction layers
- Can lead to circular dependency issues
- Makes refactoring and moving files more difficult
- Obscures the actual file structure
- Prevents effective tree-shaking in bundlers

# Naming Conventions

## Snake Case for Local Symbols

**MANDATORY**: Use snake_case for ALL local symbols within React components, including:

- State variables and their setters
- Local functions and variables
- Hook parameters and return values
- Props destructuring (when possible)
- Internal component identifiers

### ✅ Correct Local Symbol Usage:

```tsx
function SearchComponent() {
	const [search_query, set_search_query] = useState("");
	const [is_loading, set_is_loading] = useState(false);

	const handle_search_change = useCallback((value: string) => {
		set_search_query(value);
	}, []);

	const filtered_results = useMemo(() => {
		return results.filter((item) => item.title.toLowerCase().includes(search_query.toLowerCase()));
	}, [results, search_query]);

	return (
		<div className="SearchComponent">
			<input value={search_query} onChange={(e) => set_search_query(e.target.value)} />
		</div>
	);
}
```

### External API Consistency:

When interfacing with external APIs or libraries that use camelCase, keep their naming as-is but use snake_case for your local transformations:

```tsx
function UserProfile() {
	// External API uses camelCase - keep as-is
	const { firstName, lastName } = useUser();

	// Local transformations use snake_case
	const [display_name, set_display_name] = useState("");
	const [is_editing, set_is_editing] = useState(false);

	const update_display_name = useCallback(() => {
		set_display_name(`${firstName} ${lastName}`);
	}, [firstName, lastName]);
}
```

## Component Interface Naming

When defining Props interfaces for React components, use the following naming format:

**Format**: `ComponentName_Props`

### ✅ Correct Usage:

```tsx
// For a component named ThemeProvider
export interface ThemeProvider_Props {
	children: ReactNode;
	className?: string;
}

// For a component named MessageComposer
export interface MessageComposer_Props {
	onSubmit: (message: string) => void;
	placeholder?: string;
	disabled?: boolean;
}
```

# React 19 Context Patterns

## Modern Context with use Hook

**MANDATORY**: Use React 19's `use` hook instead of `useContext` for consuming context.

### Context Setup Pattern:

```tsx
import { createContext, use, useState, ReactNode } from "react";

// Context interface with snake_case
interface SearchContextType {
	search_query: string;
	set_search_query: (query: string) => void;
	is_loading: boolean;
	set_is_loading: (loading: boolean) => void;
}

const SearchContext = createContext<SearchContextType | null>(null);

// Custom hook using React 19 'use' hook
const useSearchContext = () => {
	const context = use(SearchContext);
	if (!context) {
		throw new Error("useSearchContext must be used within SearchContextProvider");
	}
	return context;
};

// Provider component with snake_case state
function SearchContextProvider({ children }: { children: ReactNode }) {
	const [search_query, set_search_query] = useState("");
	const [is_loading, set_is_loading] = useState(false);

	return (
		<SearchContext.Provider
			value={{
				search_query,
				set_search_query,
				is_loading,
				set_is_loading,
			}}
		>
			{children}
		</SearchContext.Provider>
	);
}
```

# Component Class Name Requirements

## Critical Rule: ALL Classes Must Be Prefixed

**MANDATORY**: ALL CSS classes within a React component MUST be prefixed with the component name. This applies to every single class, not just semantic ones.

### Class Name Format Requirements

#### Root Element

- Use the component name in PascalCase: `ComponentName`
- Example: `Thread`, `MessageComposer`, `UserActionBar`

#### Child Elements

- Format: `ComponentName-description-of-element-and-modifiers`
- Use kebab-case for the description part
- Include relevant state modifiers when applicable

### Implementation Guidelines

1. **ALL classes must be prefixed** - no exceptions for utility or state classes
2. **Use kebab-case for multi-word descriptions** in class names
3. **Combine with Tailwind classes** using the `cn()` utility:

```tsx
<div className={cn("Thread", "bg-background box-border flex h-full")}>
```

4. **State-aware classes must also be prefixed**:

```tsx
<button className={cn(
  "ComposerAction-send-button",
  is_loading && "ComposerAction-send-button-loading",
  "my-2.5 size-8 p-2"
)}>
```

5. **Nested components** maintain their own prefixing:

```tsx
// In Thread component - use Thread prefix
<div className={cn("Thread-composer", "sticky bottom-0")}>
  <Composer />
</div>

// In Composer component - use Composer prefix
<div className={cn("Composer", "focus-within:border-ring/20")}>
  <input className={cn("Composer-input", "placeholder:text-muted-foreground")} />
</div>
```

### Adding Custom Classes

When adding custom classes, use the prefixed naming pattern directly:

**Pattern**: `<ComponentName>-<sub-component-name>-<element-identifier>`

```tsx
// Custom class example
<div
	ref={user_button_ref}
	className={cn(
		"MainAppSidebar-clerk-wrapper", // New custom class with proper prefix
		"absolute sr-only right-[-30px] bottom-0 h-0 w-0"
	)}
>
```

## ❌ Incorrect vs ✅ Correct Class Usage

```tsx
// ❌ WRONG: Mixing prefixed and non-prefixed classes
<div className={cn("Thread", "viewport", "bg-background")}>
  <div className={cn("messages_container", "Thread_header")}>

// ✅ CORRECT: All classes properly prefixed with kebab-case
<div className={cn("Thread", "Thread-viewport", "bg-background")}>
  <div className={cn("Thread-messages-container", "Thread-header")}>
```

# Component Variant and Size Handling

## Direct String Constants Pattern

For components with multiple variants, sizes, or states, define string constants for each variation:

```tsx
// Define variant constants
const BUTTON_VARIANTS = {
	default: "Button-variant-default",
	destructive: "Button-variant-destructive",
	outline: "Button-variant-outline",
	ghost: "Button-variant-ghost",
} as const;

const BUTTON_SIZES = {
	default: "Button-size-default",
	sm: "Button-size-sm",
	lg: "Button-size-lg",
	icon: "Button-size-icon",
} as const;

type Variant = keyof typeof BUTTON_VARIANTS;
type Size = keyof typeof BUTTON_SIZES;

type Button_Props = React.ComponentProps<"button"> & {
	variant?: Variant;
	size?: Size;
};

function Button({ className, variant = "default", size = "default", ...props }: Button_Props) {
	return <button className={cn("Button", BUTTON_VARIANTS[variant], BUTTON_SIZES[size], className)} {...props} />;
}
```

### Null Values for Opt-Out Styling

Allow `null` as a valid value to opt out of variant styling entirely:

```tsx
type Variant = keyof typeof BUTTON_VARIANTS | null;

// Usage in JSX with null check
function Button({ className, variant = "default", size = "default", ...props }: Button_Props) {
	return (
		<button
			className={cn(
				"Button",
				variant && BUTTON_VARIANTS[variant], // Only applies if variant is not null
				size && BUTTON_SIZES[size],
				className,
			)}
			{...props}
		/>
	);
}
```

# Form Component Integration

When using shadcn/ui form components, integrate them with snake_case patterns:

```tsx
import { Checkbox } from "@/components/ui/checkbox";
import { Label } from "@/components/ui/label";

function ShowArchivedCheckbox({
	checked,
	onCheckedChange,
	className,
}: {
	checked: boolean;
	onCheckedChange: (checked: boolean) => void;
	className?: string;
}) {
	const checkbox_id = React.useId();

	return (
		<div className={cn("mb-4 flex items-center space-x-2", className)}>
			<Checkbox
				id={checkbox_id}
				checked={checked}
				onCheckedChange={(checked) => onCheckedChange(checked === true)}
				className={cn("ShowArchivedCheckbox-checkbox")}
			/>
			<Label htmlFor={checkbox_id} className={cn("ShowArchivedCheckbox-label", "cursor-pointer")}>
				Show archived
			</Label>
		</div>
	);
}
```

# React Hook Usage Guidelines

## Avoid useEffect When Possible

Minimize the use of `useEffect` to prevent infinite loops, dependency issues, and performance problems. Instead:

1. **Use event handlers** for user interactions and state changes
2. **Use useMemo** for synchronous data transformations
3. **Use useMemo with promises** for async data transformations that depend on other state

## Use Refs for Non-Reactive State

Use `useRef` instead of `useState` for values that don't need to trigger re-renders:

### ❌ Avoid: useState for non-reactive values

```tsx
const [is_processing, set_is_processing] = useState(false);
// These state changes cause unnecessary re-renders
```

### ✅ Prefer: useRef for non-reactive values

```tsx
const is_processing_ref = useRef(false);
const cache_ref = useRef(new Map());

// No re-renders triggered
const handle_process = async () => {
	is_processing_ref.current = true; // No re-render
	await processData();
	is_processing_ref.current = false; // No re-render
};
```

### When to Use Refs vs State

**Use `useRef` when:**

- Value is used for internal component logic only
- Value doesn't affect UI rendering
- Value is used to prevent operations (like blocking duplicate API calls)
- Value is used for caching or memoization

**Use `useState` when:**

- Value affects what's rendered in the UI
- Value is used in JSX conditionals or expressions
- Value needs to trigger re-renders when changed

## Preferred Patterns

### ✅ Prefer: useMemo for sync transformations

```tsx
const [data, set_data] = useState(null);

const transformed_data = useMemo(() => {
	return data ? processData(data) : null;
}, [data]);
```

### ✅ Prefer: Event handlers for user interactions

```tsx
const handle_toggle = useCallback(async (new_value: boolean) => {
	if (new_value) {
		const result = await processToggle();
		set_processed_result(result);
	}
	set_toggle_state(new_value);
}, []);

<button onClick={() => handle_toggle(!toggle_state)}>Toggle</button>;
```

## Guidelines Summary

- **Event handlers**: Use for user interactions, form submissions, button clicks
- **useMemo**: Use for synchronous data transformations and computations
- **useMemo + promises**: Use for async operations that depend on state changes
- **useRef**: Use for non-reactive values that don't affect UI rendering
- **useState**: Use only for values that need to trigger re-renders
- **useEffect**: Only use when you genuinely need to sync with external systems (DOM, timers, subscriptions)

## Benefits

- **Easy debugging**: Quickly identify components in browser DevTools
- **Better testing**: Reliable selectors for test automation
- **Component tracking**: Understand component hierarchy in production
- **Design system consistency**: Clear component boundaries and relationships
- **Performance**: Avoid unnecessary re-renders and infinite loops from useEffect
- **Maintainability**: Clearer data flow and fewer side effects
- **Optimization**: Use refs to prevent unnecessary re-renders for internal state
- **Modern React patterns**: Leverage React 19 features like the `use` hook
- **Consistent naming**: Snake_case for all local symbols improves code readability
