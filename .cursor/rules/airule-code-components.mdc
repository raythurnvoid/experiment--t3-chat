---
description: Guidelines for creating and styling React components, including class naming patterns, semantic classnames, and component organization
globs: packages/**/src/components/**/*.tsx
alwaysApply: false
---

React Components Guidelines

# Component Declaration

## Props Parameter Pattern

Use a single `props` parameter and destructure on the first line; keep `...rest` last to forward DOM-compatible props. This preserves access to the full `props` object for debugging/conditional logic, enables flexible prop forwarding, and allows conditional destructuring or passing the entire props object when needed.

The following rules are mandatory across this codebase:

## Do

- Use named function declarations for components.
- Accept a single `props` parameter; destructure on the first line inside the function body.
- Keep `...rest` last and forward DOM-compatible props as needed.
- Prefix all CSS classes with the component name.
- Use camelCase for props and all local symbols.
- Use React 19 ref patterns: accept `ref` as a regular prop; use `useImperativeHandle` to expose imperative handles, including multiple internal elements through a single `ref`.

## Don't

- Use `React.FC` or `FC`.
- Wrap components with `React.memo`.
- Destructure props in the function signature.
- Export anonymous arrow component expressions for top-level components.

## Prop Ordering

When destructuring component props, follow this exact order for named props, then place `...rest` last:

1. `ref` (if present)
2. `refs` (if present; can be aliased, e.g., `refs`)
3. `id`
4. `className`
5. Other props (domain-specific configuration flags, values, etc.)
6. Events (e.g., `onClick`, `onChange`, `onKeyDown`)
7. Named slots (ReactNode-like props such as `labelSlot`)
8. `children`

`...rest` must always be the final destructured item.

## Props Argument and Spread

- The component function must accept a single argument named `props`.
- Destructure at the top of the function; keep `...rest` last and spread it to the root DOM element when appropriate.

### Also applies to `_Props` type declarations

Use the same ordering when declaring fields in your `ComponentName_Props` interface. This applies to custom fields you declare; inherited DOM props from `extends React.ComponentProps<...>` are not re-ordered. Always put `children` last.

The comments should not be included in your generated code, they are only for documentation purposes.

```tsx
export type Example_Props = React.ComponentProps<"div"> & {
	ref?: Ref<HTMLDivElement>;
	id?: string;
	className?: string;
	// Other props
	variant?: "default" | "compact";
	// Events
	onClick?: React.MouseEventHandler<HTMLDivElement>;
	// Named slots
	headerSlot?: React.ReactNode;
	// Children last
	children?: React.ReactNode;
};
```

### Example

```tsx
export type Toolbar_Props = React.ComponentProps<"div"> & {
	ref?: Ref<HTMLDivElement>;
	id?: string;
	className?: string;
	variant?: "default" | "compact"; // other prop
	onClick?: React.MouseEventHandler<HTMLDivElement>; // event
	labelSlot?: React.ReactNode; // named slot
	children?: React.ReactNode;
};

export function Toolbar(props: Toolbar_Props) {
	const { ref, id, className, variant = "default", onClick, labelSlot, children, ...rest } = props;

	return (
		<div
			id={id}
			ref={ref}
			className={cn("Toolbar", `Toolbar-variant-${variant}`, className)}
			onClick={onClick}
			{...rest}
		>
			{labelSlot}
			{children}
		</div>
	);
}
```

## No Barrel Exports

- Do not create index.\* barrel files (index.ts, index.tsx, index.js).
- Always import from concrete files and export from the component file directly.
- Example: import from "./components/ui/button.tsx" or export from "./button.tsx"; do not add a directory-level index.
- Barrel files are bad for intellisense and code completion.

# Component Styles

- Declare a `_ClassNames` union type enumerating all CSS class strings. Class values are prefixed with the main component name and use kebab-case for words. Always include a root class whose value equals the component name (even if no styles are needed) so the component is identifiable in HTML.

```ts
type Thread_ClassNames = "Thread" | "Thread-header" | "Thread-actions";
```

- Use TypeScript's `satisfies` operator to validate class string literals at call sites:

```ts
<div className={cn("Thread" satisfies Thread_ClassNames)} />
```

## Subcomponents in \_ClassNames

Model subcomponents as additional class strings within the same `<ComponentName>_ClassNames` union. Use PascalCase for subcomponent root classes (e.g., `ThreadHeader`) and dash-suffixed modifiers for states, variants, and sizes on those subcomponents.

```ts
type Thread_ClassNames =
	| "Thread"
	| "Thread-inner"
	| "ThreadHeader"
	| "ThreadFooter"
	| "ThreadContent"
	| "ThreadHeader-title"
	| "ThreadMenu"
	| "ThreadMenuItem"
	| "ThreadMenuButton"
	| "ThreadMenuButton-variant-outline"
	| "ThreadMenuButton-variant-ghost"
	| "ThreadMenuButton-size-sm"
	| "ThreadMenuButton-size-lg";
```

```tsx
function ThreadHeader(props: React.ComponentProps<"div">) {
	const { className, ...rest } = props;
	return <div className={cn("ThreadHeader" satisfies Thread_ClassNames, className)} {...rest} />;
}

function ThreadMenuButton(
	props: { variant?: "outline" | "ghost"; size?: "sm" | "lg" } & React.ComponentProps<"button">,
) {
	const { className, variant = "outline", size = "sm", ...rest } = props;
	return (
		<button
			className={cn(
				"ThreadMenuButton" satisfies Thread_ClassNames,
				variant === "outline" && ("ThreadMenuButton-variant-outline" satisfies Thread_ClassNames),
				variant === "ghost" && ("ThreadMenuButton-variant-ghost" satisfies Thread_ClassNames),
				size === "sm" && ("ThreadMenuButton-size-sm" satisfies Thread_ClassNames),
				size === "lg" && ("ThreadMenuButton-size-lg" satisfies Thread_ClassNames),
				className,
			)}
			{...rest}
		/>
	);
}
```

- Use Tailwind by default for styling. When the user requests explicit CSS classes, prefer component-prefixed classes validated by the `_ClassNames` type and follow the CSS rules in [airule-code-css.mdc](mdc:.cursor/rules/airule-code-css.mdc).

- Variants and sizes must be represented directly in the component's `_ClassNames` union. Use conditional adds with `satisfies` for validation.

```ts
type Button_ClassNames =
	| "Button"
	| "Button-variant-default"
	| "Button-variant-destructive"
	| "Button-variant-outline"
	| "Button-variant-ghost"
	| "Button-size-default"
	| "Button-size-sm"
	| "Button-size-lg"
	| "Button-size-icon";

function Button(
	props: {
		className?: string;
		variant?: "default" | "destructive" | "outline" | "ghost" | null;
		size?: "default" | "sm" | "lg" | "icon";
	} & React.ComponentProps<"button">,
) {
	const { className, variant = "default", size = "default", ...rest } = props;
	return (
		<button
			className={cn(
				"Button" satisfies Button_ClassNames,
				variant === "default" && ("Button-variant-default" satisfies Button_ClassNames),
				variant === "destructive" && ("Button-variant-destructive" satisfies Button_ClassNames),
				variant === "outline" && ("Button-variant-outline" satisfies Button_ClassNames),
				variant === "ghost" && ("Button-variant-ghost" satisfies Button_ClassNames),
				size === "default" && ("Button-size-default" satisfies Button_ClassNames),
				size === "sm" && ("Button-size-sm" satisfies Button_ClassNames),
				size === "lg" && ("Button-size-lg" satisfies Button_ClassNames),
				size === "icon" && ("Button-size-icon" satisfies Button_ClassNames),
				className,
			)}
			{...rest}
		/>
	);
}
```

## Component CSS Variables (\_CssVars)

Use a `<ComponentName>_CssVars` type to model component-scoped CSS custom properties and provide defaults merged into the `style` prop. Spread defaults first, then user `style` so the user can override defaults.

```tsx
type Thread_ClassNames = "Thread" | "Thread-header" | "Thread-actions";

type Thread_CssVars = {
	"--thread-width": string;
	"--thread-width-collapsed": string;
};

const THREAD_CSS_DEFAULTS: Partial<Thread_CssVars> = {
	"--thread-width": "320px",
	"--thread-width-collapsed": "48px",
} as const;

function Thread(props: React.ComponentProps<"aside">) {
	const { className, style, ...rest } = props;
	return (
		<aside
			className={cn("Thread" satisfies Thread_ClassNames, className)}
			style={{
				...THREAD_CSS_DEFAULTS,
				...style,
			}}
			{...rest}
		/>
	);
}
```

- Prefer overriding specific properties via `className` over custom positioning. Fall back to custom CSS only when necessary.

# React 19 Context Patterns

## Modern Context with use Hook

**MANDATORY**: Use React 19's `use` hook instead of `useContext` for consuming context.

### Context Setup Pattern:

```tsx
import { createContext, use, useState, ReactNode } from "react";

// Context interface with camelCase for internal state
interface SearchContextType {
	searchQuery: string;
	setSearchQuery: (query: string) => void;
	isLoading: boolean;
	setIsLoading: (loading: boolean) => void;
}

const SearchContext = createContext<SearchContextType | null>(null);

// Custom hook using React 19 'use' hook
const useSearchContext = () => {
	const context = use(SearchContext);
	if (!context) {
		throw new Error("useSearchContext must be used within SearchContextProvider");
	}
	return context;
};

// Provider component with camelCase state
function SearchContextProvider(props: { children: ReactNode }) {
	const { children } = props;
	const [searchQuery, setSearchQuery] = useState("");
	const [isLoading, setIsLoading] = useState(false);

	return (
		<SearchContext.Provider
			value={{
				searchQuery,
				setSearchQuery,
				isLoading,
				setIsLoading,
			}}
		>
			{children}
		</SearchContext.Provider>
	);
}
```

# Refs and useImperativeHandle

## Ref as a regular prop

You must pass `ref` as a regular prop without `forwardRef`:

```tsx
// ✅ React 19: ref as regular prop (new way)
interface ButtonProps {
	ref?: Ref<HTMLButtonElement>;
	children: React.ReactNode;
}

function Button(props: ButtonProps) {
	const { ref, children, ...rest } = props;

	return (
		<button ref={ref} {...rest}>
			{children}
		</button>
	);
}
```

## Callback Refs with Cleanup Functions

Callback refs can return cleanup functions:

```tsx
// ✅ React 19: Callback refs with cleanup
function ResizeObserverComponent(props: ResizeObserverComponent_Props) {
	const { onResize } = props;
	const [height, setHeight] = useState(0);

	const measuredRef = (node: HTMLDivElement | null) => {
		if (!node) return;

		const observer = new ResizeObserver(([entry]) => {
			setHeight(entry.contentRect.height);
			onResize?.(entry.contentRect.height);
		});

		observer.observe(node);

		// ✅ NEW: Return cleanup function
		return () => {
			observer.disconnect();
		};
	};

	return <div ref={measuredRef}>Height: {Math.round(height)}px</div>;
}
```

## Imperative handle pattern

```tsx
import React, { useImperativeHandle, useRef, useState, Ref } from "react";

export interface MyWidget_Ref {
	rootElement: HTMLDivElement | null;
	focusInput: () => void;
	getValue: () => string;
}

export type MyWidget_Props = React.ComponentProps<"div"> & {
	ref?: Ref<MyWidget_Ref>;
	initialValue?: string;
};

export function MyWidget(props: MyWidget_Props) {
	const { ref, initialValue = "", className, ...rest } = props;
	const rootRef = useRef<HTMLDivElement>(null);
	const inputRef = useRef<HTMLInputElement>(null);
	const [value, setValue] = useState(initialValue);

	useImperativeHandle(
		ref,
		() => ({
			rootElement: rootRef.current,
			focusInput: () => inputRef.current?.focus(),
			getValue: () => value,
		}),
		[value],
	);

	// When forwarding a child ref directly:
	// useImperativeHandle(ref, () => childRef.current!, []);

	return (
		<div ref={rootRef} className={cn("MyWidget", className)} {...rest}>
			<input ref={inputRef} value={value} onChange={(e) => setValue(e.target.value)} className={cn("MyWidget-input")} />
		</div>
	);
}
```

## Exposing multiple elements via a single ref

```tsx
import React, { useImperativeHandle, useRef, Ref } from "react";

export interface Drawer_Ref {
	root: HTMLDivElement | null;
	header: HTMLElement | null;
	scrollContainer: HTMLDivElement | null;
}

export type Drawer_Props = React.ComponentProps<"div"> & {
	ref?: Ref<Drawer_Ref>;
};

export function Drawer(props: Drawer_Props) {
	const { ref, className, ...rest } = props;
	const rootRef = useRef<HTMLDivElement>(null);
	const headerRef = useRef<HTMLElement>(null);
	const scrollRef = useRef<HTMLDivElement>(null);

	useImperativeHandle(
		ref,
		() => ({
			root: rootRef.current,
			header: headerRef.current,
			scrollContainer: scrollRef.current,
		}),
		[],
	);

	return (
		<div ref={rootRef} className={cn("Drawer", className)} {...rest}>
			<header ref={headerRef} className={cn("Drawer-header")} />
			<div ref={scrollRef} className={cn("Drawer-scroll-container")} />
		</div>
	);
}
```

## Use `useRef` When:

- Simple element access
- Non-reactive values that don't trigger re-renders
- Storing timers, intervals, or other imperative handles

```tsx
// ✅ Object ref for simple access
const inputRef = useRef<HTMLInputElement>(null);

const focusInput = () => {
	inputRef.current?.focus();
};
```
