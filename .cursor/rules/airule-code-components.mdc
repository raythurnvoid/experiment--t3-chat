---
description: Guidelines for creating and styling React components, including class naming patterns, semantic classnames, and component organization
globs: packages/**/src/components/**/*.tsx
alwaysApply: false
---

React Components Guidelines

# Component Declaration

## Props Parameter Pattern

Use a single `props` parameter and destructure on the first line; keep `...rest` last to forward DOM-compatible props. This preserves access to the full `props` object for debugging/conditional logic, enables flexible prop forwarding, and allows conditional destructuring or passing the entire props object when needed.

The following rules are mandatory across this codebase:

## Do

- Use named function declarations for components.
- Accept a single `props` parameter; destructure on the first line inside the function body.
- Keep `...rest` last and forward DOM-compatible props as needed.
- Prefix all CSS classes with the component name.
- Use camelCase for props and all local symbols.
- Use React 19 ref patterns: accept `ref` as a regular prop; use `useImperativeHandle` to expose imperative handles, including multiple internal elements through a single `ref`.

## Don't

- Use `React.FC` or `FC`.
- Wrap components with `React.memo`.
- Destructure props in the function signature.
- Export anonymous arrow component expressions for top-level components.

## Prop Ordering

When destructuring component props, follow this exact order for named props, then place `...rest` last:

1. `ref` (if present)
2. `refs` (if present; can be aliased, e.g., `refs`)
3. `id`
4. `className`
5. Other props (domain-specific configuration flags, values, etc.)
6. Events (e.g., `onClick`, `onChange`, `onKeyDown`)
7. Named slots (ReactNode-like props such as `labelSlot`)
8. `children`

`...rest` must always be the final destructured item.

## Props Argument and Spread

- The component function must accept a single argument named `props`.
- Destructure at the top of the function; keep `...rest` last and spread it to the root DOM element when appropriate.

### Also applies to `_Props` type declarations

Use the same ordering when declaring fields in your `ComponentName_Props` interface. This applies to custom fields you declare; inherited DOM props from `extends React.ComponentProps<...>` are not re-ordered. Always put `children` last.

The comments should not be included in your generated code, they are only for documentation purposes.

```tsx
export type Example_Props = React.ComponentProps<"div"> & {
	ref?: Ref<HTMLDivElement>;
	id?: string;
	className?: string;
	// Other props
	variant?: "default" | "compact";
	// Events
	onClick?: React.MouseEventHandler<HTMLDivElement>;
	// Named slots
	headerSlot?: React.ReactNode;
	// Children last
	children?: React.ReactNode;
};
```

### Example

```tsx
export type Toolbar_Props = React.ComponentProps<"div"> & {
	ref?: Ref<HTMLDivElement>;
	id?: string;
	className?: string;
	variant?: "default" | "compact"; // other prop
	onClick?: React.MouseEventHandler<HTMLDivElement>; // event
	labelSlot?: React.ReactNode; // named slot
	children?: React.ReactNode;
};

export function Toolbar(props: Toolbar_Props) {
	const { ref, id, className, variant = "default", onClick, labelSlot, children, ...rest } = props;

	return (
		<div
			id={id}
			ref={ref}
			className={cn("Toolbar", `Toolbar-variant-${variant}`, className)}
			onClick={onClick}
			{...rest}
		>
			{labelSlot}
			{children}
		</div>
	);
}
```

## No Barrel Exports

- Do not create index.\* barrel files (index.ts, index.tsx, index.js).
- Always import from concrete files and export from the component file directly.
- Example: import from "./components/ui/button.tsx" or export from "./button.tsx"; do not add a directory-level index.
- Barrel files are bad for intellisense and code completion.

# Component Styles

- Define all classes in a `CLASS_NAMES` constant. Classes are prefixed with the main component name and use kebab-case for words. Always create a root class `CLASS_NAMES.root` whose value equals the component name (even if no styles are needed) so the component is identifiable in HTML.

```ts
const CLASS_NAMES = {
	root: "Thread",
	header: "Thread-header",
	actions: "Thread-actions",
} as const;
```

- Use Tailwind by default for styling. When the user requests explicit CSS classes, prefer class names from `CLASS_NAMES` and follow the CSS rules in [airule-code-css.mdc](mdc:.cursor/rules/airule-code-css.mdc).

- For multiple states like variants and sizes, define string constants that map to prefixed classes, and compose them with Tailwind via `cn()`.

```ts
const BUTTON_VARIANTS = {
	default: "Button-variant-default",
	destructive: "Button-variant-destructive",
	outline: "Button-variant-outline",
	ghost: "Button-variant-ghost",
} as const;

const BUTTON_SIZES = {
	default: "Button-size-default",
	sm: "Button-size-sm",
	lg: "Button-size-lg",
	icon: "Button-size-icon",
} as const;

function Button(props: { className?: string; variant?: keyof typeof BUTTON_VARIANTS | null; size?: keyof typeof BUTTON_SIZES } & React.ComponentProps<"button">) {
	const { className, variant = "default", size = "default", ...rest } = props;
	return (
		<button
			className={cn(
				CLASS_NAMES.root,
				variant && BUTTON_VARIANTS[variant],
				BUTTON_SIZES[size],
				className,
			)}
			{...rest}
		/>
	);
}
```

- Prefer overriding specific properties via `className` over custom positioning. Fall back to custom CSS only when necessary.

## Component Static Values via Object.assign (preferred)

Attach static values (e.g., `classNames`) to a named component function using `Object.assign`. Keep the inner component as a named function for Fast Refresh and clear DevTools display names.

```tsx
const CLASS_NAMES = { root: "MyComp" } as const;

const MyComp = Object.assign(
	function MyComp(props: React.ComponentProps<"div">) {
		const { className, ...rest } = props;
		return <div className={cn(CLASS_NAMES.root, className)} {...rest} />;
	},
	{ classNames: CLASS_NAMES },
);
```

Do:

- Keep the function named (not anonymous).
- Attach only static, serializable data (e.g., `classNames`).

Don’t:

- Don’t attach dynamic functions or environment objects.
- Don’t convert to anonymous functions.

# React 19 Context Patterns

## Modern Context with use Hook

**MANDATORY**: Use React 19's `use` hook instead of `useContext` for consuming context.

### Context Setup Pattern:

```tsx
import { createContext, use, useState, ReactNode } from "react";

// Context interface with camelCase for internal state
interface SearchContextType {
	searchQuery: string;
	setSearchQuery: (query: string) => void;
	isLoading: boolean;
	setIsLoading: (loading: boolean) => void;
}

const SearchContext = createContext<SearchContextType | null>(null);

// Custom hook using React 19 'use' hook
const useSearchContext = () => {
	const context = use(SearchContext);
	if (!context) {
		throw new Error("useSearchContext must be used within SearchContextProvider");
	}
	return context;
};

// Provider component with camelCase state
function SearchContextProvider(props: { children: ReactNode }) {
	const { children } = props;
	const [searchQuery, setSearchQuery] = useState("");
	const [isLoading, setIsLoading] = useState(false);

	return (
		<SearchContext.Provider
			value={{
				searchQuery,
				setSearchQuery,
				isLoading,
				setIsLoading,
			}}
		>
			{children}
		</SearchContext.Provider>
	);
}
```

# Refs and useImperativeHandle

## Ref as a regular prop

You must pass `ref` as a regular prop without `forwardRef`:

```tsx
// ✅ React 19: ref as regular prop (new way)
interface ButtonProps {
	ref?: Ref<HTMLButtonElement>;
	children: React.ReactNode;
}

function Button(props: ButtonProps) {
	const { ref, children, ...rest } = props;

	return (
		<button ref={ref} {...rest}>
			{children}
		</button>
	);
}
```

## Callback Refs with Cleanup Functions

Callback refs can return cleanup functions:

```tsx
// ✅ React 19: Callback refs with cleanup
function ResizeObserverComponent(props: ResizeObserverComponent_Props) {
	const { onResize } = props;
	const [height, setHeight] = useState(0);

	const measuredRef = (node: HTMLDivElement | null) => {
		if (!node) return;

		const observer = new ResizeObserver(([entry]) => {
			setHeight(entry.contentRect.height);
			onResize?.(entry.contentRect.height);
		});

		observer.observe(node);

		// ✅ NEW: Return cleanup function
		return () => {
			observer.disconnect();
		};
	};

	return <div ref={measuredRef}>Height: {Math.round(height)}px</div>;
}
```

## Imperative handle pattern

```tsx
import React, { useImperativeHandle, useRef, useState, Ref } from "react";

export interface MyWidget_Ref {
	rootElement: HTMLDivElement | null;
	focusInput: () => void;
	getValue: () => string;
}

export type MyWidget_Props = React.ComponentProps<"div"> & {
	ref?: Ref<MyWidget_Ref>;
	initialValue?: string;
};

export function MyWidget(props: MyWidget_Props) {
	const { ref, initialValue = "", className, ...rest } = props;
	const rootRef = useRef<HTMLDivElement>(null);
	const inputRef = useRef<HTMLInputElement>(null);
	const [value, setValue] = useState(initialValue);

	useImperativeHandle(
		ref,
		() => ({
			rootElement: rootRef.current,
			focusInput: () => inputRef.current?.focus(),
			getValue: () => value,
		}),
		[value],
	);

	// When forwarding a child ref directly:
	// useImperativeHandle(ref, () => childRef.current!, []);

	return (
		<div ref={rootRef} className={cn("MyWidget", className)} {...rest}>
			<input ref={inputRef} value={value} onChange={(e) => setValue(e.target.value)} className={cn("MyWidget-input")} />
		</div>
	);
}
```

## Exposing multiple elements via a single ref

```tsx
import React, { useImperativeHandle, useRef, Ref } from "react";

export interface Drawer_Ref {
	root: HTMLDivElement | null;
	header: HTMLElement | null;
	scrollContainer: HTMLDivElement | null;
}

export type Drawer_Props = React.ComponentProps<"div"> & {
	ref?: Ref<Drawer_Ref>;
};

export function Drawer(props: Drawer_Props) {
	const { ref, className, ...rest } = props;
	const rootRef = useRef<HTMLDivElement>(null);
	const headerRef = useRef<HTMLElement>(null);
	const scrollRef = useRef<HTMLDivElement>(null);

	useImperativeHandle(
		ref,
		() => ({
			root: rootRef.current,
			header: headerRef.current,
			scrollContainer: scrollRef.current,
		}),
		[],
	);

	return (
		<div ref={rootRef} className={cn("Drawer", className)} {...rest}>
			<header ref={headerRef} className={cn("Drawer-header")} />
			<div ref={scrollRef} className={cn("Drawer-scroll-container")} />
		</div>
	);
}
```

## Use `useRef` When:

- Simple element access
- Non-reactive values that don't trigger re-renders
- Storing timers, intervals, or other imperative handles

```tsx
// ✅ Object ref for simple access
const inputRef = useRef<HTMLInputElement>(null);

const focusInput = () => {
	inputRef.current?.focus();
};
```
