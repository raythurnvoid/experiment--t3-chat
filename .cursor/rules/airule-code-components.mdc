---
description: Guidelines for creating and styling React components, including class naming patterns, semantic classnames, and component organization
globs: packages/**/src/components/**/*.tsx
alwaysApply: false
---

React Components Guidelines

# Component Function Signature Pattern

## MANDATORY: Props Parameter Pattern

**CRITICAL**: All React components MUST use a single `props` parameter instead of destructuring in the function signature, followed by destructuring on the first line of the component.

### ✅ Correct Pattern:

```tsx
interface ComponentName_Props {
	title: string;
	isActive: boolean;
	onClick: () => void;
	className?: string;
}

function ComponentName(props: ComponentName_Props) {
	const { title, isActive, onClick, className, ...rest } = props;
	// Component logic here

	return (
		<div className={cn("ComponentName", className)} {...rest}>
			{title}
		</div>
	);
}
```

### ❌ Avoid: Destructuring in Function Signature

```tsx
// ❌ DON'T DO THIS
function ComponentName({ title, isActive, onClick, className }: ComponentName_Props) {
	// Component logic
}
```

### Benefits of This Pattern:

1. **Props object access**: Full `props` object remains available for debugging and conditional logic
2. **Rest parameters**: Easy access to `...rest` for spreading unused props
3. **Flexibility**: Can conditionally destructure props or pass entire props object to children
4. **Debugging**: Can log entire `props` object when troubleshooting
5. **Prop forwarding**: Easier to forward all props to child components when needed

### Examples with Rest Parameters:

```tsx
function Button(props: Button_Props) {
	const { variant, size, className, children, ...rest } = props;

	return (
		<button
			className={cn("Button", VARIANTS[variant], SIZES[size], className)}
			{...rest} // Forward all other DOM props
		>
			{children}
		</button>
	);
}

function CustomInput(props: CustomInput_Props) {
	const { label, error, className, ...inputProps } = props;

	return (
		<div className={cn("CustomInput-wrapper", className)}>
			<label>{label}</label>
			<input
				className={cn("CustomInput-field", error && "CustomInput-field-error")}
				{...inputProps} // Forward all input-specific props
			/>
			{error && <span className="CustomInput-error">{error}</span>}
		</div>
	);
}
```

## Component Declaration Rules (Project Standard)

The following rules are mandatory across this codebase:

### BAN: React.FC

Do not use `React.FC` (or `FC`) for component typing. Type the props on the function parameter instead.

```tsx
// ❌ Do not use
const Button: React.FC<Button_Props> = (props) => {
	const { children } = props;
	return <button>{children}</button>;
};

// ✅ Use regular function with typed props
function Button(props: Button_Props) {
	const { children, ...rest } = props;
	return <button {...rest}>{children}</button>;
}
```

### BAN: React.memo

Do not wrap components with `React.memo`. Components must be declared as regular functions without memoization wrappers.

```tsx
// ❌ Do not use
const Toolbar = React.memo(function Toolbar(props: Toolbar_Props) {
	const { className } = props;
	return <div className={className} />;
});

// ✅ Use regular function
function Toolbar(props: Toolbar_Props) {
	const { className } = props;
	return <div className={className} />;
}
```

### REQUIRED: Regular Function Declarations

Prefer named function declarations for all components. This improves DevTools names, stack traces, and aligns with React 19 best practices.

```tsx
// ❌ Avoid anonymous arrow component expressions for top-level components
export const Card = (props: Card_Props) => {
	const { children } = props;
	return <section>{children}</section>;
};

// ✅ Prefer named function declarations
export function Card(props: Card_Props) {
	const { children } = props;
	return <section>{children}</section>;
}
```

### REQUIRED: Props Parameter Pattern (First-line Destructuring)

All components must accept a single `props` parameter and destructure on the first line inside the function body.

```tsx
// ❌ Do not destructure in the signature
function Input({ value, onChange, className }: Input_Props) {
	return <input value={value} onChange={onChange} className={className} />;
}

// ✅ Destructure on the first line
function Input(props: Input_Props) {
	const { value, onChange, className, ...rest } = props;
	return <input value={value} onChange={onChange} className={className} {...rest} />;
}
```

# Understanding Component Styles First

## Critical: Read Component Styles Before Custom Solutions

**MANDATORY**: When working with component libraries (especially shadcn/ui), always understand the existing component styles before implementing custom solutions.

### Process for Styling Issues:

1. **Inspect the component's default CSS** - Understand what margins, padding, positioning the component uses by default
2. **Identify specific style properties** that need adjustment
3. **Override specific properties** using className props rather than creating custom solutions
4. **Only resort to custom positioning/styling** if working with existing styles doesn't achieve the desired result

### ✅ Correct Approach: Work with Existing Styles

```tsx
// Example: Fixing sidebar indentation issues
// Instead of custom absolute positioning, override the component's default margins/padding
<SidebarMenuSub className="mx-0 ml-3.5 px-0 pl-2.5">
	{/* This works with the component's existing structure */}
</SidebarMenuSub>
```

### ❌ Avoid: Custom Solutions First

```tsx
// Instead of immediately jumping to custom absolute positioning:
<SidebarMenuSubItem className="relative">
  <button className="absolute right-1 top-1/2 -translate-y-1/2">
    {/* Custom positioning that fights against component defaults */}
  </button>
</SidebarMenuSubItem>

// First try working with the component's existing styles:
<SidebarMenuSub className="mx-0 ml-3.5 px-0 pl-2.5">
  {/* Much cleaner and more maintainable */}
</SidebarMenuSub>
```

### Why This Matters:

- **Maintainability**: Working with component defaults is more future-proof
- **Consistency**: Maintains the design system's intended behavior
- **Performance**: Avoids complex CSS that fights against existing styles
- **Debugging**: Easier to understand and modify later
- **Component Updates**: Less likely to break when components are updated

### Investigation Steps:

1. **Use browser DevTools** to inspect the component's applied styles
2. **Check the component's source code** to understand its structure
3. **Look for existing className props** that allow style customization
4. **Test with specific margin/padding overrides** before custom solutions
5. **Document the solution** for future reference

# File Organization

## No Barrel Exports - Index Files Are Banned

**IMPORTANT**: Barrel exports via index files (`index.ts`, `index.tsx`, `index.js`, etc.) are banned in this repository.

### ❌ Do Not Create:

- `src/components/ui/index.ts`
- `src/hooks/index.ts`
- `src/utils/index.ts`
- Any `index.*` files in component directories

### ✅ Instead:

- Import directly from specific files: `import { Button } from "./components/ui/button"`
- Export components from their own files: `export { Button } from "./button"`
- Use explicit file paths in imports

### Why Barrel Exports Are Banned:

- Makes imports less explicit and harder to trace
- Creates unnecessary abstraction layers
- Can lead to circular dependency issues
- Makes refactoring and moving files more difficult
- Obscures the actual file structure
- Prevents effective tree-shaking in bundlers

# Naming Conventions

## Props Naming - Critical Distinction

**CRITICAL**: Props naming depends on whether they will be spread onto DOM elements or not.

### Props for DOM Elements (camelCase Required)

**MANDATORY**: Props that will be spread onto DOM elements (`{...props}`) MUST use camelCase to match React/DOM conventions.

```tsx
// ✅ CORRECT: Props that can be spread onto DOM elements
interface Button_Props extends React.ComponentProps<"button"> {
	variant?: "default" | "destructive" | "outline";
	size?: "default" | "sm" | "lg";
	className?: string;
	onClick?: () => void;
	disabled?: boolean;
	children?: React.ReactNode;
}

function Button(props: Button_Props) {
	const { className, variant = "default", size = "default", ...rest } = props;

	return (
		<button
			className={cn("Button", BUTTON_VARIANTS[variant], BUTTON_SIZES[size], className)}
			{...rest} // ✅ Works because props use camelCase
		/>
	);
}
```

### Custom Component Props (camelCase Required)

For props that are specific to your component and will NOT be spread onto DOM elements, use camelCase for consistency:

```tsx
// ✅ CORRECT: Custom component props (not spread onto DOM)
interface SearchFilter_Props {
	searchQuery: string; // Custom prop - camelCase
	onSearchChange: (query: string) => void; // Custom prop - camelCase
	showArchived: boolean; // Custom prop - camelCase
	className?: string; // Will be manually assigned - camelCase
}

function SearchFilter(props: SearchFilter_Props) {
	const { searchQuery, onSearchChange, showArchived, className } = props;

	return (
		<div className={cn("SearchFilter", className)}>
			<input
				value={searchQuery}
				onChange={(e) => onSearchChange(e.target.value)} // Used manually, not spread
			/>
		</div>
	);
}
```

### Props Destructuring Pattern

When destructuring props that extend DOM element props, separate the custom props from the spreadable props:

```tsx
interface CustomButton_Props extends React.ComponentProps<"button"> {
	customBehavior?: boolean; // Custom prop - camelCase
	specialMode?: "normal" | "enhanced"; // Custom prop - camelCase
}

function CustomButton(props: CustomButton_Props) {
	const { customBehavior, specialMode, className, ...rest } = props;

	// Local variables use camelCase
	const enhancedClass = specialMode === "enhanced" ? "CustomButton-enhanced" : "";

	return (
		<button
			className={cn("CustomButton", enhancedClass, className)}
			{...rest} // ✅ Safe to spread DOM props
		/>
	);
}
```

## CamelCase for Local Symbols

**MANDATORY**: Use camelCase for ALL local symbols within React components, including:

- State variables and their setters
- Local functions and variables
- Hook parameters and return values
- Internal component identifiers
- Object properties and method parameters

### ✅ Correct Local Symbol Usage:

```tsx
function SearchComponent(props: SearchComponent_Props) {
	const { initialQuery } = props;
	const [searchQuery, setSearchQuery] = useState(initialQuery || "");
	const [isLoading, setIsLoading] = useState(false);

	const handleSearchChange = useCallback((value: string) => {
		setSearchQuery(value);
	}, []);

	const filteredResults = useMemo(() => {
		return results.filter((item) => item.title.toLowerCase().includes(searchQuery.toLowerCase()));
	}, [results, searchQuery]);

	return (
		<div className="SearchComponent">
			<input value={searchQuery} onChange={(e) => setSearchQuery(e.target.value)} />
		</div>
	);
}
```

### External API Consistency:

When interfacing with external APIs or libraries that use camelCase, keep their naming as-is and use camelCase for your local transformations:

```tsx
function UserProfile(props: UserProfile_Props) {
	const { userId } = props;
	// External API uses camelCase - keep as-is
	const { firstName, lastName } = useUser(userId);

	// Local transformations use camelCase
	const [displayName, setDisplayName] = useState("");
	const [isEditing, setIsEditing] = useState(false);

	const updateDisplayName = useCallback(() => {
		setDisplayName(`${firstName} ${lastName}`);
	}, [firstName, lastName]);
```

## Component Interface Naming

When defining Props interfaces for React components, use the following naming format:

**Format**: `ComponentName_Props`

### ✅ Correct Usage:

```tsx
// For a component named ThemeProvider
export interface ThemeProvider_Props {
	children: ReactNode;
	className?: string; // camelCase for DOM compatibility
	custom_theme?: string; // snake_case for custom prop
}

// For a component named MessageComposer
export interface MessageComposer_Props extends React.ComponentProps<"div"> {
	onSubmit: (message: string) => void; // camelCase - could be spread
	placeholder?: string; // camelCase - standard DOM attribute
	custom_validation?: boolean; // snake_case - custom prop
}
```

# React 19 Context Patterns

## Modern Context with use Hook

**MANDATORY**: Use React 19's `use` hook instead of `useContext` for consuming context.

### Context Setup Pattern:

```tsx
import { createContext, use, useState, ReactNode } from "react";

// Context interface with camelCase for internal state
interface SearchContextType {
	searchQuery: string;
	setSearchQuery: (query: string) => void;
	isLoading: boolean;
	setIsLoading: (loading: boolean) => void;
}

const SearchContext = createContext<SearchContextType | null>(null);

// Custom hook using React 19 'use' hook
const useSearchContext = () => {
	const context = use(SearchContext);
	if (!context) {
		throw new Error("useSearchContext must be used within SearchContextProvider");
	}
	return context;
};

// Provider component with camelCase state
function SearchContextProvider(props: { children: ReactNode }) {
	const { children } = props;
	const [searchQuery, setSearchQuery] = useState("");
	const [isLoading, setIsLoading] = useState(false);

	return (
		<SearchContext.Provider
			value={{
				searchQuery,
				setSearchQuery,
				isLoading,
				setIsLoading,
			}}
		>
			{children}
		</SearchContext.Provider>
	);
}
```

# React 19 Ref Patterns and Modern Ref Handling

## Ref Types in React 19 - No Breaking Changes

**IMPORTANT**: `React.MutableRefObject<T>` is **NOT deprecated** in React 19. This type is still the standard return type for `useRef` and remains fully supported.

```tsx
// ✅ CORRECT: MutableRefObject is still the standard type in React 19
interface TreeItemComponent_Props {
	treeRef: React.MutableRefObject<TreeRef | null>;
}

const treeRef = useRef<TreeRef | null>(null); // Returns MutableRefObject<TreeRef | null>
```

## What Actually Changed in React 19

### 1. forwardRef is Now Optional

**NEW in React 19**: You can pass `ref` as a regular prop without `forwardRef`:

```tsx
// ✅ React 19: ref as regular prop (new way)
interface ButtonProps {
	ref?: React.RefObject<HTMLButtonElement>;
	children: React.ReactNode;
}

function Button(props: ButtonProps) {
	const { ref, children, ...rest } = props;

	return (
		<button ref={ref} {...rest}>
			{children}
		</button>
	);
}

// ✅ Still supported: forwardRef (traditional way)
const Button = forwardRef<HTMLButtonElement, ButtonProps>(function Button(props, ref) {
	const { children, ...rest } = props;

	return (
		<button ref={ref} {...rest}>
			{children}
		</button>
	);
});
```

### React 19 Component Definition Best Practices

**PREFERRED in React 19**: Use regular function declarations and avoid unnecessary complexity:

#### ✅ Preferred: Regular Function Declaration

```tsx
// ✅ PREFERRED: Regular function declaration with ref as prop
export type IconButton_Props = React.ComponentProps<typeof Button> & {
	tooltip?: string;
	side?: "top" | "bottom" | "left" | "right";
	ref?: React.RefObject<HTMLButtonElement>;
};

export function IconButton(props: IconButton_Props) {
	const { children, tooltip, side = "bottom", className, ref, ...rest } = props;

	return (
		<Button ref={ref} className={cn("IconButton", className)} {...rest}>
			{children}
		</Button>
	);
}
```

**Benefits:**

- ✅ **Automatic naming**: Function name automatically becomes component name in DevTools
- ✅ **No displayName needed**: Eliminates boilerplate
- ✅ **Simpler syntax**: No forwardRef wrapper complexity
- ✅ **Better debugging**: Clear function names in stack traces
- ✅ **Future-proof**: Aligned with React 19 patterns

#### ❌ Avoid: Unnecessary Complexity

```tsx
// ❌ AVOID: forwardRef when not needed (React 19)
export const IconButton = forwardRef<HTMLButtonElement, IconButton_Props>((props, ref) => {
	const { children, tooltip, side = "bottom", className, ...rest } = props;
	// Component logic
});

// ❌ AVOID: Manual displayName when using function declarations
IconButton.displayName = "IconButton"; // Unnecessary with function declarations
```

#### When to Still Use forwardRef

Only use `forwardRef` in React 19 when:

- Working with libraries that expect the forwardRef pattern
- Need to maintain backward compatibility
- Component name would be unclear without explicit naming

```tsx
// ✅ Acceptable: When library integration requires it
const CustomInput = forwardRef<HTMLInputElement, CustomInputProps>(function CustomInput(props, ref) {
	const { ...inputProps } = props;
	return <SomeLibraryInput {...inputProps} ref={ref} />;
});
```

### 2. Callback Refs with Cleanup Functions

**NEW in React 19**: Callback refs can return cleanup functions:

```tsx
// ✅ React 19: Callback refs with cleanup
function ResizeObserverComponent(props: ResizeObserverComponent_Props) {
	const { onResize } = props;
	const [height, setHeight] = useState(0);

	const measuredRef = (node: HTMLDivElement | null) => {
		if (!node) return;

		const observer = new ResizeObserver(([entry]) => {
			setHeight(entry.contentRect.height);
			onResize?.(entry.contentRect.height);
		});

		observer.observe(node);

		// ✅ NEW: Return cleanup function
		return () => {
			observer.disconnect();
		};
	};

	return <div ref={measuredRef}>Height: {Math.round(height)}px</div>;
}
```

### 3. Modern Ref Combination Patterns

**RECOMMENDED**: Use `useCombinedRef` for handling multiple refs efficiently:

```tsx
// ✅ Modern pattern: Combined refs
type RefItem<T> = ((element: T | null) => void) | React.MutableRefObject<T | null> | null | undefined;

function useCombinedRef<T>(...refs: RefItem<T>[]) {
	return useCallback(
		(element: T | null) => {
			refs.forEach((ref) => {
				if (!ref) return;
				if (typeof ref === "function") {
					ref(element);
				} else {
					ref.current = element;
				}
			});
		},
		[refs],
	);
}

// Usage
const Input = forwardRef<HTMLInputElement, InputProps>(function Input(props, ref) {
	const { ...inputProps } = props;
	const localRef = useRef<HTMLInputElement>(null);
	const combinedRef = useCombinedRef(ref, localRef);

	return <input {...inputProps} ref={combinedRef} />;
});
```

## When to Use Each Ref Pattern

### Use `useRef` (Object Refs) When:

- Simple element access
- Non-reactive values that don't trigger re-renders
- Storing timers, intervals, or other imperative handles

```tsx
// ✅ Object ref for simple access
const inputRef = useRef<HTMLInputElement>(null);

const focusInput = () => {
	inputRef.current?.focus();
};
```

### Use Callback Refs When:

- Need to react to mount/unmount
- Dynamic elements that change type
- Need cleanup logic (React 19+)
- Working with external libraries requiring setup/teardown

```tsx
// ✅ Callback ref for lifecycle control
const callbackRef = useCallback((node: HTMLElement | null) => {
	if (node) {
		// Setup logic
		const cleanup = setupExternalLibrary(node);

		// React 19: Return cleanup function
		return cleanup;
	}
}, []);
```

### Avoid `useCallback` for Stable Refs

**IMPORTANT**: Don't use `useCallback` just to "stabilize" ref functions. Extract to component-level functions instead:

```tsx
// ❌ AVOID: Using useCallback for ref stabilization
const measuredRef = useCallback((node: HTMLElement | null) => {
	if (node) {
		node.scrollIntoView({ behavior: "smooth" });
	}
}, []); // This creates a dependency on useCallback working

// ✅ PREFER: Extract to stable function
function scrollIntoView(node: HTMLElement | null) {
	if (node) {
		node.scrollIntoView({ behavior: "smooth" });
	}
}

function Component(props: Component_Props) {
	const { children } = props;
	return <div ref={scrollIntoView}>{children}</div>;
}
```

## React Compiler Compatibility

**FUTURE-PROOFING**: Avoid `useCallback` for ref functions that your code depends on. The React Compiler may optimize away memoization, breaking functionality:

```tsx
// ❌ RISKY: Depending on useCallback for correctness
const handleRef = useCallback((node) => {
	// If this MUST run only once, useCallback is risky
	if (node) setupOnce(node);
}, []);

// ✅ SAFE: Make the function naturally stable
function handleRef(node: HTMLElement | null) {
	if (node) {
		// Use patterns that work regardless of call frequency
		if (!node.dataset.initialized) {
			setupOnce(node);
			node.dataset.initialized = "true";
		}
	}
}
```

## Ref Type Patterns

### Standard Ref Types

```tsx
// DOM element refs
const buttonRef = useRef<HTMLButtonElement>(null);
const divRef = useRef<HTMLDivElement>(null);
const inputRef = useRef<HTMLInputElement>(null);

// Component instance refs (when using forwardRef)
const customComponentRef = useRef<CustomComponent_Ref>(null);

// Value refs (non-DOM)
const timerRef = useRef<NodeJS.Timeout | null>(null);
const callbackRef = useRef<(() => void) | null>(null);
```

### Modern Combined Ref Types

```tsx
// Union type for flexible ref handling
type FlexibleRef<T> = React.MutableRefObject<T | null> | ((instance: T | null) => void) | null;

interface ComponentProps {
	ref?: FlexibleRef<HTMLDivElement>;
}
```

# Component Class Name Requirements

## Critical Rule: ALL Classes Must Be Prefixed

**MANDATORY**: ALL CSS classes within a React component MUST be prefixed with the component name. This applies to every single class, not just semantic ones.

### Class Name Format Requirements

#### Root Element

- Use the component name in PascalCase: `ComponentName`
- Example: `Thread`, `MessageComposer`, `UserActionBar`

#### Child Elements

- Format: `ComponentName-description-of-element-and-modifiers`
- Use kebab-case for the description part
- Include relevant state modifiers when applicable

### Implementation Guidelines

1. **ALL classes must be prefixed** - no exceptions for utility or state classes
2. **Use kebab-case for multi-word descriptions** in class names
3. **Combine with Tailwind classes** using the `cn()` utility:

```tsx
<div className={cn("Thread", "bg-background box-border flex h-full")}>
```

4. **State-aware classes must also be prefixed**:

```tsx
<button className={cn(
  "ComposerAction-send-button",
  isLoading && "ComposerAction-send-button-loading",
  "my-2.5 size-8 p-2"
)}>
```

5. **Nested components** maintain their own prefixing:

```tsx
// In Thread component - use Thread prefix
<div className={cn("Thread-composer", "sticky bottom-0")}>
  <Composer />
</div>

// In Composer component - use Composer prefix
<div className={cn("Composer", "focus-within:border-ring/20")}>
  <input className={cn("Composer-input", "placeholder:text-muted-foreground")} />
</div>
```

### Adding Custom Classes

When adding custom classes, use the prefixed naming pattern directly:

**Pattern**: `<ComponentName>-<sub-component-name>-<element-identifier>`

```tsx
// Custom class example
<div
	ref={userButtonRef}
	className={cn(
		"MainAppSidebar-clerk-wrapper", // New custom class with proper prefix
		"absolute sr-only right-[-30px] bottom-0 h-0 w-0"
	)}
>
```

## ❌ Incorrect vs ✅ Correct Class Usage

```tsx
// ❌ WRONG: Mixing prefixed and non-prefixed classes
<div className={cn("Thread", "viewport", "bg-background")}>
  <div className={cn("messages_container", "Thread_header")}>

// ✅ CORRECT: All classes properly prefixed with kebab-case
<div className={cn("Thread", "Thread-viewport", "bg-background")}>
  <div className={cn("Thread-messages-container", "Thread-header")}>
```

# Component Variant and Size Handling

## Direct String Constants Pattern

For components with multiple variants, sizes, or states, define string constants for each variation:

```tsx
// Define variant constants
const BUTTON_VARIANTS = {
	default: "Button-variant-default",
	destructive: "Button-variant-destructive",
	outline: "Button-variant-outline",
	ghost: "Button-variant-ghost",
} as const;

const BUTTON_SIZES = {
	default: "Button-size-default",
	sm: "Button-size-sm",
	lg: "Button-size-lg",
	icon: "Button-size-icon",
} as const;

type Variant = keyof typeof BUTTON_VARIANTS;
type Size = keyof typeof BUTTON_SIZES;

type Button_Props = React.ComponentProps<"button"> & {
	variant?: Variant;
	size?: Size;
};

function Button(props: Button_Props) {
	const { className, variant = "default", size = "default", ...rest } = props;

	return <button className={cn("Button", BUTTON_VARIANTS[variant], BUTTON_SIZES[size], className)} {...rest} />;
}
```

### Null Values for Opt-Out Styling

Allow `null` as a valid value to opt out of variant styling entirely:

```tsx
type Variant = keyof typeof BUTTON_VARIANTS | null;

// Usage in JSX with null check
function Button(props: Button_Props) {
	const { className, variant = "default", size = "default", ...rest } = props;

	return (
		<button
			className={cn(
				"Button",
				variant && BUTTON_VARIANTS[variant], // Only applies if variant is not null
				size && BUTTON_SIZES[size],
				className,
			)}
			{...rest}
		/>
	);
}
```

# Form Component Integration

When using shadcn/ui form components, integrate them with the appropriate naming patterns:

```tsx
import { Checkbox } from "@/components/ui/checkbox";
import { Label } from "@/components/ui/label";

interface ShowArchivedCheckbox_Props {
	checked: boolean;
	onCheckedChange: (checked: boolean) => void; // camelCase - matches Checkbox API
	className?: string; // camelCase - for DOM compatibility
}

function ShowArchivedCheckbox(props: ShowArchivedCheckbox_Props) {
	const { checked, onCheckedChange, className } = props;
	const checkboxId = React.useId(); // Local variable - camelCase

	return (
		<div className={cn("mb-4 flex items-center space-x-2", className)}>
			<Checkbox
				id={checkboxId}
				checked={checked}
				onCheckedChange={(checked) => onCheckedChange(checked === true)}
				className={cn("ShowArchivedCheckbox-checkbox")}
			/>
			<Label htmlFor={checkboxId} className={cn("ShowArchivedCheckbox-label", "cursor-pointer")}>
				Show archived
			</Label>
		</div>
	);
}
```

# React Hook Usage Guidelines

## Avoid useEffect When Possible

Minimize the use of `useEffect` to prevent infinite loops, dependency issues, and performance problems. Instead:

1. **Use event handlers** for user interactions and state changes
2. **Use useMemo** for synchronous data transformations
3. **Use useMemo with promises** for async data transformations that depend on other state

## Use Refs for Non-Reactive State

Use `useRef` instead of `useState` for values that don't need to trigger re-renders:

### ❌ Avoid: useState for non-reactive values

```tsx
const [isProcessing, setIsProcessing] = useState(false);
// These state changes cause unnecessary re-renders
```

### ✅ Prefer: useRef for non-reactive values

```tsx
const isProcessingRef = useRef(false);
const cacheRef = useRef(new Map());

// No re-renders triggered
const handleProcess = async () => {
	isProcessingRef.current = true; // No re-render
	await processData();
	isProcessingRef.current = false; // No re-render
};
```

### When to Use Refs vs State

**Use `useRef` when:**

- Value is used for internal component logic only
- Value doesn't affect UI rendering
- Value is used to prevent operations (like blocking duplicate API calls)
- Value is used for caching or memoization

**Use `useState` when:**

- Value affects what's rendered in the UI
- Value is used in JSX conditionals or expressions
- Value needs to trigger re-renders when changed

## Preferred Patterns

### ✅ Prefer: useMemo for sync transformations

```tsx
const [data, setData] = useState(null);

const transformedData = useMemo(() => {
	return data ? processData(data) : null;
}, [data]);
```

### ✅ Prefer: Event handlers for user interactions

```tsx
const handleToggle = useCallback(async (newValue: boolean) => {
	if (newValue) {
		const result = await processToggle();
		setProcessedResult(result);
	}
	setToggleState(newValue);
}, []);

<button onClick={() => handleToggle(!toggleState)}>Toggle</button>;
```

## Guidelines Summary

- **Event handlers**: Use for user interactions, form submissions, button clicks
- **useMemo**: Use for synchronous data transformations and computations
- **useMemo + promises**: Use for async operations that depend on state changes
- **useRef**: Use for non-reactive values that don't affect UI rendering
- **useState**: Use only for values that need to trigger re-renders
- **useEffect**: Only use when you genuinely need to sync with external systems (DOM, timers, subscriptions)

## Benefits

- **Easy debugging**: Quickly identify components in browser DevTools
- **Better testing**: Reliable selectors for test automation
- **Component tracking**: Understand component hierarchy in production
- **Design system consistency**: Clear component boundaries and relationships
- **Performance**: Avoid unnecessary re-renders and infinite loops from useEffect
- **Maintainability**: Clearer data flow and fewer side effects
- **Optimization**: Use refs to prevent unnecessary re-renders for internal state
- **Modern React patterns**: Leverage React 19 features like the `use` hook and new ref patterns
- **Future-proof**: Compatible with React Compiler and modern React development
- **Consistent naming**: Root-level exports use snake_case for namespacing, local variables use camelCase for consistency with modern JavaScript conventions
- **Props accessibility**: Full props object available for debugging, conditional logic, and flexible prop forwarding
