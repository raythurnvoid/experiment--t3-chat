---
globs: packages/app/src/**/*.css
alwaysApply: false
---

# CSS Approach for This Project

This project uses vanilla `.css` files for styling components.

## Default Approach: Vanilla CSS

By default, you should use vanilla CSS (co-located `.css` files imported by the corresponding `.tsx` modules) for component styling.

# File Structure

- Each component's CSS must be in a separate `.css` file
- File must be imported in the corresponding `.tsx` file
- Use modern CSS features including CSS nesting

# Layering

```css
@layer components {
	/* Feature-level / context-specific component styles (e.g. ai-chat, page-editor, routes) */
}

@layer common_components {
	/* Reusable app “primitives” used across many contexts (e.g. MyButton, MyInput, MyModal, MyIconButton) */
}
```

## Which layer should I use?

- Use `@layer components` for **high-level, feature/context styles** (routes, ai-chat, page-editor, sidebars specific to a page/feature).
- Use `@layer common_components` for **shared/reusable UI components** (the `My*` component CSS files, small primitives used broadly).

# Grouping Style (Required for module CSS)

When a `.css` file is paired with a `.tsx` module (same feature/module, imported by that module), the CSS must be structured to make it obvious how it maps to the TSX file.

## Regions: keep TSX and CSS aligned

- If the TSX module uses `// #region ...` markers, the paired CSS file must use matching `/* #region ... */` markers.
- **Region label text must match exactly** (including spacing/casing).
- Prefer reading top-down: **`root` → deeper sections**. If both TSX and CSS use regions, it’s ideal for both files to use the same top-down order, but the **required** constraint is matching region labels (not identical ordering).
- Do not add “extra” regions in the paired CSS that don’t exist in the TSX module.

```css
@layer components {
	/* #region root */
	.MyModule {
		/* ... */
	}
	/* #endregion root */

	/* #region toolbar */
	.MyModuleToolbar {
		/* ... */
	}
	/* #endregion toolbar */
}
```

## Group selectors by component, then by role

- Keep each component’s selectors contiguous (don’t interleave other components).
- For each component, prefer this adjacency:
  - Base selector (e.g. `.MyThing`)
  - Direct children / slots (e.g. `.MyThing-title`, `.MyThing-actions`)
  - Modifiers/states (e.g. `.MyThing-state-open`, `.MyThing-variant-...`)
  - Contextual overrides (e.g. `.MyThing-state-open .MyThing-title`)

## One module per file

- A module `.css` file should primarily contain styles for components defined in the paired TSX module.
- If a separate TSX module/component needs styles, it should generally have its own `.css` file imported by that module (instead of “parking” styles in an unrelated file).

# Class Naming Convention

## Base Component

- Use PascalCase for component class names
- Match class name with component name
- Example: `.Button`, `.Card`, `.Modal`

## Modifiers

- Use single dash with explicit modifier type naming
- Pattern: `ComponentName-modifierType-value`
- **Variants**: `Button-variant-default`, `Button-variant-destructive`
- **Sizes**: `Button-size-default`, `Button-size-sm`, `Button-size-lg`
- **States**: `Button-state-loading`, `Button-state-disabled`

```css
/* ✅ Good - explicit modifier naming */
.Button-variant-destructive {
}
.Button-size-lg {
}

/* ❌ Bad - double dashes or unclear naming */
.Button--destructive {
}
.Button--lg {
}
```

## CSS Selector Compatibility: Critical Dash Requirements

### Important Rule for CSS Selectors

**CRITICAL**: When creating class names that will be used in CSS selectors (including `:has(...)`, `:not()`, `:is()`, etc.), you **MUST use dashes (kebab-case) instead of underscores** for the selectors to work properly.

### Why Dashes Are Required

- **CSS Standard**: CSS class selectors expect dashes as word separators
- **Browser Parsing**: Browsers parse CSS class names with dashes correctly
- **Selector Matching**: CSS selector engines rely on standard class naming conventions

### Examples of Correct CSS-Compatible Class Names

```css
/* ✅ Correct: Dashes work in all CSS selectors */
.Button-variant-primary {
	background: hsl(var(--primary));
}

.Card-size-large {
	padding: 2rem;
}

/* ❌ Incorrect: Underscores don't work in CSS selectors */
.Button_variant_primary {
	/* This may not work as expected */
}
```

### Class Naming Pattern for CSS Files

When creating CSS files, ensure all class names use dashes:

```css
/* ✅ Correct CSS class naming */
.MessageComposer-input-field {
	/* Base styles */
}

.MessageComposer-send-button {
	/* Button styles */
}

.MessageComposer-attachment-area {
	/* Attachment styles */
}
```

### Integration with React Components

When your CSS classes need to work with advanced CSS selectors or other CSS features, ensure the class values in your React components use dashes:

```tsx
// In React component file
const MessageComposer_class_names = {
	root: "MessageComposer",
	input_field: "MessageComposer-input-field", // ✅ Dashes for CSS compatibility
	send_button: "MessageComposer-send-button", // ✅ Dashes for CSS compatibility
};

// In CSS file
.MessageComposer-input-field {
	border: 1px solid hsl(var(--border));
}
```

### When to Use Dashes vs Underscores

- **CSS class values**: Always use dashes (`MessageComposer-input-field`)
- **React object properties**: Use underscores (`input_field`)
- **Variable names**: Use underscores (`class_names`)
- **CSS selectors**: Always use dashes (`.MessageComposer-input-field`)

# Modern CSS Nesting

- Use the `&` syntax for nesting selectors within a component
- Keep all component states nested under the base component selector to maintain low specificity
- For nested selectors, use simple pseudo-classes like `&:hover` and `&:focus-visible`

```css
/* ✅ Good - using modern CSS nesting with low specificity */
.Button {
	/* Base styles */

	&:hover {
		/* Hover styles with low specificity */
	}

	&:focus-visible {
		/* Focus styles with low specificity */
	}

	& svg {
		/* SVG child styles with low specificity */
		pointer-events: none;
		flex-shrink: 0;
	}
}

/* ❌ Bad - separate selectors increase complexity */
.Button {
	/* Base styles */
}

.Button:hover {
	/* Hover styles - separate selector */
}
```

# Property Grouping and Organization

- Use empty lines to group related properties
- Common property groups:
  - Box model (position, display, box-sizing)
  - Layout (flex, grid, gap, align-items)
  - Spacing (padding, margin)
  - Typography (font properties)
  - Visual (color, background, border)
  - Transitions and animations

```css
.Button {
	box-sizing: border-box;
	position: relative;

	display: inline-flex;
	align-items: center;
	justify-content: center;
	gap: 0.5rem;

	padding: 0.5rem 1rem;
	border-radius: 0.375rem;

	font-size: 0.875rem;
	font-weight: 500;
	line-height: 1.25rem;

	background: hsl(var(--primary));
	color: hsl(var(--primary-foreground));

	transition: all 0.15s ease;
}
```

# Flex alignment keywords

- Prefer logical keywords `start` / `end` over `flex-start` / `flex-end` (e.g. `align-self: end`, `justify-content: start`) so alignment stays consistent across writing modes.

# Size Units: Avoid rem for Sizing

**Avoid using `rem` or `em` units for sizing properties** (padding, width, height, margin) unless explicitly requested by the user.

```css
/* ✅ Good - px for precise sizing */
.Button {
	padding: 8px 16px;
	width: 120px;
	height: 40px;
	margin: 4px;
	gap: 8px;
	border-width: 1px;
	top: 8px;
	left: 12px;
}

/* ✅ Good - rem for typography */
.Button {
	font-size: 0.875rem;
	line-height: 1.25rem;
}

/* ❌ Avoid - rem for sizing unless requested */
.Button {
	padding: 0.5rem 1rem;
	width: 7.5rem;
	height: 2.5rem;
	margin: 0.25rem;
	gap: 0.5rem;
	top: 0.25rem;
	left: 0.5rem;
}
```

# CSS Custom Properties

- Use CSS custom properties with `hsl()` function
- Pattern: `hsl(var(--variable-name))`
- For opacity variants: `hsl(var(--variable-name) / 0.9)`

```css
/* ✅ Good */
background: hsl(var(--primary));
color: hsl(var(--primary-foreground));
border-color: hsl(var(--destructive) / 0.2);

/* ❌ Bad - missing hsl() wrapper */
background: var(--primary);
```

# Dark Mode Support

- Use `@media (prefers-color-scheme: dark)` for dark theme handling
- Place dark mode overrides within the component scope

```css
.Button-variant-outline {
	background: hsl(var(--background));
	border: 1px solid hsl(var(--border));

	@media (prefers-color-scheme: dark) {
		background: hsl(var(--input) / 0.3);
		border-color: hsl(var(--input));
	}
}
```

# State Handling

- Use nested pseudo-classes for interactive states
- Handle disabled, focus, hover, and active states consistently

```css
.Button {
	/* Base styles */

	&:disabled {
		pointer-events: none;
		opacity: 0.5;
	}

	&:focus-visible {
		outline: none;
		border-color: var(--color-fg-12);
	}

	&:hover {
		background: hsl(var(--primary) / 0.9);
	}
}
```

# Child Element Styling

- Use low-specificity child selectors via nesting
- Use semantic child selectors

```css
.Button {
	/* Base styles */

	& svg {
		pointer-events: none;
		flex-shrink: 0;

		&:not([class*="size-"]) {
			width: 1rem;
			height: 1rem;
		}
	}

	&:has(> svg) {
		padding-left: 0.75rem;
		padding-right: 0.75rem;
	}
}
```

# Container Performance & Clipping

Prefer `contain: content` for container components (e.g., sidebars) instead of `overflow: hidden` to limit layout/paint scope without clipping descendants. This plays well with animated size changes.

```css
/* Example */
.MySidebar {
	contain: content;
	transition: width 200ms linear;
}

/* Class-based state (instead of attributes) */
.MySidebar-state-collapsed {
	width: 47px;
}
.MySidebar-state-closed {
	display: none;
}
```

# Example Complete Component

```css
@layer components {
	.Card {
		box-sizing: border-box;
		position: relative;

		display: flex;
		flex-direction: column;

		padding: 1.5rem;
		border-radius: 0.5rem;
		border: 1px solid hsl(var(--border));

		background: hsl(var(--card));
		color: hsl(var(--card-foreground));

		box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1);
	}

	/* Variant: Elevated */
	.Card-variant-elevated {
		box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1);

		&:hover {
			box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1);
		}
	}

	/* Size: Compact */
	.Card-size-compact {
		padding: 1rem;
	}

	/* Size: Large */
	.Card-size-large {
		padding: 2rem;
	}
}
```

# Benefits of This Approach

- **Low specificity**: Easy to override styles when needed
- **Modern CSS**: Uses latest nesting and selector features
- **Maintainable**: Clear naming convention and organization
- **Performance**: Efficient CSS with minimal specificity conflicts
- **Scalable**: Consistent patterns across all components
